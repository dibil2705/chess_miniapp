<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chess Board</title>
  <style>
    :root{
      --dark:#769656;
      --light:#eeeed2;
      --bg:#111;
      --panel:rgba(255,255,255,.06);
      --border:rgba(255,255,255,.12);
      --text:#fff;
    }

    body{
      margin:16px;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:var(--bg);
      color:var(--text);
    }

    .wrap{ max-width: 560px; }

    .board{
      width:min(520px, 100%);
      aspect-ratio: 1 / 1;
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      grid-auto-rows: 1fr;
      border-radius:14px;
      overflow:hidden;
      box-shadow: 0 12px 40px rgba(0,0,0,.45);
      user-select:none;
      -webkit-user-select:none;
      touch-action: manipulation;
    }

    .sq{
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: clamp(22px, 6vw, 44px);
      line-height: 1;
      aspect-ratio: 1 / 1;
      overflow: hidden;
      min-width: 0;
      min-height: 0;
    }

    .light{ background:var(--light); }
    .dark{ background:var(--dark); }

    /* pieces (so pieces never affect square size) */
    .piece{
      /* IMPORTANT: do NOT make the draggable element full-square size,
         otherwise the drag-ghost can look like you drag the whole cell. */
      width: auto;
      height: auto;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor: grab;
      line-height: 1;
      pointer-events: auto;
    }
    .piece.white{ }
    .piece.white img{
      width: 140.712%;
      height: 140.712%;
      display:block;
      pointer-events: none; /* so drag events stay on .piece */
      user-select:none;
      -webkit-user-select:none;
    }
    .piece.black{ }
    .piece.black img{
      width: 140.712%;
      height: 140.712%;
      display:block;
      pointer-events: none; /* so drag events stay on .piece */
      user-select:none;
      -webkit-user-select:none;
    }

    /* drag feedback */
    .sq.drop{ outline: 3px solid rgba(255,255,255,.55); outline-offset:-3px; }

    .row{ display:flex; gap:10px; margin-top: 12px; flex-wrap:wrap; }
    button{
      padding:10px 12px;
      border-radius:12px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.08);
      color:#fff;
      cursor:pointer;
    }
    button:active{ transform: translateY(1px); }

    .box{
      margin-top:12px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--border);
      background:var(--panel);
    }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

    .hint{ opacity:.8; font-size: 13px; margin-top: 8px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h2 style="margin:0 0 10px 0;">Chess Board</h2>

    <div id="board" class="board" aria-label="Chess board"></div>

    <div class="row">
      <button id="resetBtn">Reset</button>
      <button id="flipBtn">Flip</button>
      <button id="loadStartBtn">Load Start</button>
    </div>

    <div class="box">
      <div><b>FEN:</b></div>
      <div id="fenOut" class="mono" style="word-break: break-all;"></div>
      <div class="hint">Можно перетаскивать фигуры. Проверки легальности ходов нет (чистый фронтенд без движка).</div>
    </div>
  </div>

  <script>
    // --- White pieces: local SVGs (relative to this HTML file) ---
    // IMPORTANT: in URLs use forward slashes: icone/white/...
    const WHITE_SVG = {
      P: 'icone/white/Chess_plt45.svg',
      N: 'icone/white/Chess_nlt45.svg',
      B: 'icone/white/Chess_blt45.svg',
      R: 'icone/white/Chess_rlt45.svg',
      Q: 'icone/white/Chess_qlt45.svg',
      K: 'icone/white/Chess_klt45.svg'
    };

    // --- Black pieces: local SVGs (relative to this HTML file) ---
    // IMPORTANT: in URLs use forward slashes: icone/black/...
    const BLACK_SVG = {
      p: 'icone/black/Chess_pdt45.svg',
      n: 'icone/black/Chess_ndt45.svg',
      b: 'icone/black/Chess_bdt45.svg',
      r: 'icone/black/Chess_rdt45.svg',
      q: 'icone/black/Chess_qdt45.svg',
      k: 'icone/black/Chess_kdt45.svg'
    };

    // Default: start position
    const START_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';

    let flipped = false;
    let boardState = fenToBoard(START_FEN);

    const boardEl = document.getElementById('board');
    const fenOutEl = document.getElementById('fenOut');

    function fenToBoard(fen){
      // returns 8x8 array; each cell is piece char or ''
      const placement = fen.split(' ')[0];
      const rows = placement.split('/');
      if (rows.length !== 8) throw new Error('Bad FEN');
      const b = [];
      for (const r of rows){
        const row = [];
        for (const ch of r){
          if (/[1-8]/.test(ch)){
            for (let i=0;i<Number(ch);i++) row.push('');
          } else {
            row.push(ch);
          }
        }
        if (row.length !== 8) throw new Error('Bad FEN row');
        b.push(row);
      }
      return b;
    }

    function boardToFen(b){
      // only placement part (enough for visual)
      const rows = b.map(row => {
        let out = '';
        let empties = 0;
        for (const cell of row){
          if (!cell){
            empties++;
          } else {
            if (empties){ out += String(empties); empties = 0; }
            out += cell;
          }
        }
        if (empties) out += String(empties);
        return out;
      });
      // keep other fields from START_FEN for simplicity
      return rows.join('/') + ' w - - 0 1';
    }

    function idxToCoord(i){
      // i 0..63 -> {r,c} in boardState coords (0 top)
      return { r: Math.floor(i/8), c: i%8 };
    }

    function coordToDisplay(r,c){
      // apply flip mapping
      if (!flipped) return { r, c };
      return { r: 7 - r, c: 7 - c };
    }

    function displayToCoord(dr,dc){
      // reverse mapping
      if (!flipped) return { r: dr, c: dc };
      return { r: 7 - dr, c: 7 - dc };
    }

    function render(){
      boardEl.innerHTML = '';
      for (let dr=0; dr<8; dr++){
        for (let dc=0; dc<8; dc++){
          const { r, c } = displayToCoord(dr, dc);
          const piece = boardState[r][c];

          const sq = document.createElement('div');
          sq.className = 'sq ' + (((dr+dc)%2===0) ? 'light' : 'dark');
          sq.dataset.dr = String(dr);
          sq.dataset.dc = String(dc);

          if (piece){
            const p = document.createElement('div');
            const isBlack = (piece === piece.toLowerCase());
            p.className = 'piece ' + (isBlack ? 'black' : 'white');

            if (isBlack) {
              const img = document.createElement('img');
              img.alt = '';
              img.src = BLACK_SVG[piece] || '';
              img.draggable = false; // keep drag handling on container
              p.appendChild(img);
            } else {
              const img = document.createElement('img');
              img.alt = '';
              img.src = WHITE_SVG[piece] || '';
              img.draggable = false; // keep drag handling on container
              p.appendChild(img);
            }
            p.draggable = true;
            p.dataset.fromR = String(r);
            p.dataset.fromC = String(c);
            p.addEventListener('dragstart', onDragStart);
            p.addEventListener('dragend', onDragEnd);
            sq.appendChild(p);
          }

          sq.addEventListener('dragover', onDragOver);
          sq.addEventListener('dragleave', onDragLeave);
          sq.addEventListener('drop', onDrop);

          boardEl.appendChild(sq);
        }
      }

      fenOutEl.textContent = boardToFen(boardState);
    }

    let dragFrom = null; // {r,c}

    function onDragStart(e){
      const fromR = Number(e.target.dataset.fromR);
      const fromC = Number(e.target.dataset.fromC);
      dragFrom = { r: fromR, c: fromC };
      e.dataTransfer.setData('text/plain', JSON.stringify(dragFrom));
      e.dataTransfer.effectAllowed = 'move';

      // Drag image: only the piece (not a full-square ghost).
      const ghost = e.target.cloneNode(true);
      ghost.style.position = 'absolute';
      ghost.style.top = '-9999px';
      ghost.style.left = '-9999px';
      ghost.style.width = 'auto';
      ghost.style.height = 'auto';
      ghost.style.background = 'transparent';
      ghost.style.padding = '0';
      ghost.style.margin = '0';
      document.body.appendChild(ghost);

      const x = ghost.offsetWidth / 2;
      const y = ghost.offsetHeight / 2;
      if (e.dataTransfer.setDragImage) e.dataTransfer.setDragImage(ghost, x, y);

      setTimeout(() => ghost.remove(), 0);
    }

    function onDragEnd(){
      dragFrom = null;
      document.querySelectorAll('.sq.drop').forEach(el => el.classList.remove('drop'));
    }

    function onDragOver(e){
      e.preventDefault();
      e.currentTarget.classList.add('drop');
      e.dataTransfer.dropEffect = 'move';
    }

    function onDragLeave(e){
      e.currentTarget.classList.remove('drop');
    }

    function onDrop(e){
      e.preventDefault();
      e.currentTarget.classList.remove('drop');

      let from;
      try{
        from = JSON.parse(e.dataTransfer.getData('text/plain'));
      } catch {
        from = dragFrom;
      }
      if (!from) return;

      const dr = Number(e.currentTarget.dataset.dr);
      const dc = Number(e.currentTarget.dataset.dc);
      const { r: toR, c: toC } = displayToCoord(dr, dc);

      const piece = boardState[from.r][from.c];
      if (!piece) return;

      // move piece (captures overwrite)
      boardState[from.r][from.c] = '';
      boardState[toR][toC] = piece;

      render();
    }

    document.getElementById('resetBtn').addEventListener('click', () => {
      boardState = fenToBoard(START_FEN);
      render();
    });

    document.getElementById('flipBtn').addEventListener('click', () => {
      flipped = !flipped;
      render();
    });

    document.getElementById('loadStartBtn').addEventListener('click', () => {
      // start position (same as START_FEN but explicit)
      boardState = fenToBoard('rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w - - 0 1');
      render();
    });

    // initial render
    render();
  </script>
</body>
</html>
