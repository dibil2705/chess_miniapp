<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <title>Stockfish анализ</title>
  <style>
    :root{
      --bg:#111;
      --panel:rgba(255,255,255,.06);
      --border:rgba(255,255,255,.12);
      --text:#fff;
    }
    body{
      margin:0;
      padding:16px;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:var(--bg);
      color:var(--text);
    }
    .wrap{ max-width: 960px; margin:0 auto; display:grid; gap:12px; }
    .panel{
      padding:14px;
      border-radius:12px;
      border:1px solid var(--border);
      background:var(--panel);
      box-shadow: 0 12px 30px rgba(0,0,0,.35);
    }
    h2{ margin:0 0 6px 0; }
    code{ word-break: break-all; }
    .status{ opacity:.85; margin:4px 0 0 0; font-size:14px; }
    .list{ margin:10px 0 0 0; padding:0; list-style:none; display:grid; gap:10px; }
    .list li{ border:1px solid var(--border); border-radius:10px; padding:10px; background: rgba(0,0,0,.35); }
    .actions{ display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }
    .btn{ cursor:pointer; border:1px solid var(--border); background:rgba(255,255,255,.08); color:var(--text); padding:10px 14px; border-radius:10px; font-weight:600; }
    .btn:disabled{ opacity:.5; cursor:not-allowed; }
    .field{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:10px; }
    .field input{ flex:1 1 240px; padding:10px; border-radius:10px; border:1px solid var(--border); background:rgba(0,0,0,.35); color:var(--text); }
    .mono{ font-family: ui-monospace, SFMono-Regular, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace; }
  </style>
</head>
<body>
  <div class="wrap">
    <div>
      <h2>Stockfish анализ позиции</h2>
      <p class="status">Окно анализа открывается из главной доски и использует переданный FEN.</p>
    </div>

    <div class="panel">
      <div><strong>FEN:</strong> <code id="fenText"></code></div>
      <div class="actions">
        <button class="btn" id="refreshBtn">Обновить анализ</button>
      </div>
      <p id="engineStatus" class="status">Готовимся к анализу...</p>
      <ul id="analysisList" class="list" aria-live="polite" aria-atomic="true"></ul>
    </div>

    <div class="panel">
      <h3 style="margin:0">Проверка хода</h3>
      <p class="status">Введите ход в формате UCI или передайте его из основной доски.</p>
      <div class="field">
        <input id="moveInput" type="text" inputmode="text" autocomplete="off" placeholder="Например: e2e4" />
        <button class="btn" id="evaluateBtn">Проверить</button>
      </div>
      <div id="moveStatus" class="status" style="margin-top:8px"></div>
      <ul id="moveDetails" class="list"></ul>
    </div>
  </div>

  <script>
    const params = new URLSearchParams(window.location.search);
    const fen = params.get('fen');
    const moveFromQuery = params.get('move') || '';

    const fenTextEl = document.getElementById('fenText');
    const statusEl = document.getElementById('engineStatus');
    const analysisListEl = document.getElementById('analysisList');
    const refreshBtn = document.getElementById('refreshBtn');
    const moveInput = document.getElementById('moveInput');
    const evaluateBtn = document.getElementById('evaluateBtn');
    const moveStatusEl = document.getElementById('moveStatus');
    const moveDetailsEl = document.getElementById('moveDetails');

    const ANALYZE_URL = 'http://127.0.0.1:8000/analyze';
    const EVAL_URL = 'http://127.0.0.1:8000/evaluate_move';
    const CACHE_TTL_MS = 10_000;
    const analyzeCache = new Map();

    function renderAnalysisLines(lines = [], { fromCache = false } = {}){
      analysisListEl.innerHTML = '';
      if (!lines.length){
        const empty = document.createElement('li');
        empty.textContent = 'Нет данных анализа';
        analysisListEl.appendChild(empty);
        return;
      }
      lines.slice(0, 3).forEach((line, idx) => {
        const li = document.createElement('li');
        const title = document.createElement('div');
        title.innerHTML = `<strong>#${idx + 1}</strong> ${line.best_move_uci || '—'}`;
        const scoreText = line.mate !== undefined && line.mate !== null
          ? `Мат за ${line.mate}`
          : (line.score_cp !== undefined && line.score_cp !== null ? `${(Number(line.score_cp) / 100).toFixed(2)} cp` : '—');
        const score = document.createElement('div');
        score.innerHTML = `<span class="mono">${scoreText}</span>`;
        const pv = document.createElement('div');
        pv.textContent = line.pv_san || '—';
        pv.classList.add('mono');
        li.appendChild(title);
        li.appendChild(score);
        li.appendChild(pv);
        analysisListEl.appendChild(li);
      });
      statusEl.textContent = fromCache ? 'Показан кешированный анализ (до 10 секунд).' : 'Анализ обновлён.';
    }

    function renderMoveResult(data){
      moveDetailsEl.innerHTML = '';
      if (!data){
        moveStatusEl.textContent = 'Нет данных по ходу.';
        return;
      }
      moveStatusEl.textContent = `Оценка: ${data.label || '—'}`;
      const rows = [
        { label: 'Дельта (cp)', value: data.delta_cp },
        { label: 'Лучший ход', value: data.best_move_uci },
        { label: 'Лучшая линия', value: data.best_line?.pv_san },
        { label: 'Линия после хода', value: data.after_line?.pv_san },
      ];
      rows.forEach((row) => {
        const li = document.createElement('li');
        const title = document.createElement('div');
        title.innerHTML = `<strong>${row.label}</strong>`;
        const value = document.createElement('div');
        value.textContent = row.value !== undefined && row.value !== null ? row.value : '—';
        value.classList.add('mono');
        li.appendChild(title);
        li.appendChild(value);
        moveDetailsEl.appendChild(li);
      });
    }

    function extractErrorDetail(errObj, fallback){
      if (errObj && typeof errObj === 'object' && 'detail' in errObj){
        if (typeof errObj.detail === 'string') return errObj.detail;
        try { return JSON.stringify(errObj.detail); } catch (_) {}
      }
      return fallback || 'Неизвестная ошибка';
    }

    async function fetchJson(url, payload){
      const response = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      const text = await response.text();
      let data = null;
      try { data = text ? JSON.parse(text) : null; } catch (_) { data = null; }
      if (!response.ok){
        const detail = extractErrorDetail(data, text || `${response.status} ${response.statusText}`);
        throw new Error(detail);
      }
      return data;
    }

    async function analyzePosition(force = false){
      if (!fen){
        statusEl.textContent = 'FEN не передан. Вернитесь на главную и откройте анализ заново.';
        return;
      }

      const cached = analyzeCache.get(fen);
      const now = Date.now();
      if (!force && cached && now - cached.timestamp < CACHE_TTL_MS){
        renderAnalysisLines(cached.data?.lines || [], { fromCache: true });
        return;
      }

      statusEl.textContent = 'Запрашиваем анализ у сервера...';
      refreshBtn.disabled = true;
      try {
        const payload = { fen, movetime_ms: 250, multipv: 3, side: 'turn' };
        const data = await fetchJson(ANALYZE_URL, payload);
        analyzeCache.set(fen, { timestamp: now, data });
        renderAnalysisLines(data?.lines || data?.analysis || [], { fromCache: false });
      } catch (err){
        statusEl.textContent = `Ошибка анализа: ${err.message}`;
        analysisListEl.innerHTML = '';
      } finally {
        refreshBtn.disabled = false;
      }
    }

    async function evaluateMove(moveUci){
      if (!fen){
        moveStatusEl.textContent = 'FEN не передан. Вернитесь на главную и откройте анализ заново.';
        return;
      }
      if (!moveUci){
        moveStatusEl.textContent = 'Введите ход в формате UCI.';
        return;
      }

      moveStatusEl.textContent = 'Отправляем ход на проверку...';
      evaluateBtn.disabled = true;
      try {
        const payload = { fen, move_uci: moveUci, movetime_ms: 250, side: 'turn' };
        const data = await fetchJson(EVAL_URL, payload);
        renderMoveResult(data);
      } catch (err){
        moveStatusEl.textContent = `Ошибка проверки: ${err.message}`;
        moveDetailsEl.innerHTML = '';
      } finally {
        evaluateBtn.disabled = false;
      }
    }

    function handleIncomingMove(event){
      const data = event?.data;
      if (!data || typeof data !== 'object') return;
      if (data.type === 'evaluate-move' && data.move_uci){
        moveInput.value = data.move_uci;
        evaluateMove(data.move_uci);
      }
    }

    function init(){
      fenTextEl.textContent = fen || '—';
      moveInput.value = moveFromQuery;
      analyzePosition();
      refreshBtn.addEventListener('click', () => analyzePosition(true));
      evaluateBtn.addEventListener('click', () => evaluateMove(moveInput.value.trim()));
      window.addEventListener('message', handleIncomingMove);
      if (moveFromQuery){
        evaluateMove(moveFromQuery);
      }
    }

    init();
  </script>
</body>
</html>
