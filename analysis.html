<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <title>Stockfish анализ</title>
  <script src="https://code.iconify.design/3/3.1.1/iconify.min.js"></script>
  <style>
    :root{
      --dark:#769656;
      --light:#eeeed2;
      --bg:#111;
      --panel:rgba(255,255,255,.06);
      --border:rgba(255,255,255,.12);
      --text:#fff;
    }
    *, *::before, *::after{ box-sizing: border-box; }
    body{
      margin:0;
      padding:16px 16px 120px;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:var(--bg);
      color:var(--text);
      overflow-x:hidden;
    }
    .wrap{
      max-width: 1180px;
      width: min(1180px, 100%);
      margin:0 auto;
      display:grid;
      gap:14px;
    }
    .layout{ display:flex; flex-direction:column; gap:14px; align-items:stretch; border:none; }
    .top-bar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .panel{
      padding:14px;
      border-radius:12px;
      border:1px solid var(--border);
      background: none;
    }
    .panel.board-panel{ border:none; }
    h2{ margin:0 0 6px 0; }
    code{ word-break: break-all; }
    .status{ opacity:.85; margin:4px 0 0 0; font-size:14px; }
    .list{ margin:10px 0 0 0; padding:0; list-style:none; display:grid; gap:10px; }
    .list li{ border:1px solid var(--border); border-radius:10px; padding:10px; background: rgba(0,0,0,.35); }
    .actions{ display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }
    .btn{ cursor:pointer; border:1px solid var(--border); background:rgba(255,255,255,.08); color:var(--text); padding:10px 14px; border-radius:10px; font-weight:600; }
    .btn:disabled{ opacity:.5; cursor:not-allowed; }
    .mono{
      font-family: ui-monospace, SFMono-Regular, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace;
      word-break: break-word;
      overflow-wrap: anywhere;
    }

    /* board */
    .board-panel{ display:grid; gap:12px; justify-items:center; }
    .board-wrapper{
      position: relative;
      width:min(620px, 100%);
      margin:0 auto;
      display:grid;
      grid-template-columns: 18px auto 1fr;
      grid-template-rows: 1fr auto;
      grid-template-areas:
        "cp ranks board"
        "cp . files";
      column-gap: 10px;
      row-gap: 8px;
      align-items: stretch;
    }
    .board{
      grid-area: board;
      width:100%;
      aspect-ratio: 1 / 1;
      display:block;
      border-radius:14px;
      overflow:hidden;
      user-select:none;
      -webkit-user-select:none;
      touch-action: none;
      position:relative;
    }
    .board-squares{
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      grid-auto-rows: 1fr;
      width:100%;
      height:100%;
    }
    .board-arrows{
      position:absolute;
      inset:0;
      pointer-events:none;
    }
    .arrow-path{
      stroke:#6ccf70;
      stroke-width:10;
      stroke-linecap:round;
      stroke-linejoin:round;
      fill:none;
      opacity:0.65;
    }
    .arrow-head{
      fill:#6ccf70;
      opacity:0.65;
    }
    .eval-bar{
      grid-area: cp;
      position: relative;
      width: 18px;
      background: linear-gradient(180deg, #333 0%, #f5f5f5 100%);
      border-radius: 10px;
      overflow:hidden;
      border:1px solid var(--border);
    }
    .eval-fill{
      position:absolute;
      bottom:0;
      left:0;
      right:0;
      background:#f5f5f5;
      transition:height .2s ease;
      height:50%;
    }
    .eval-label{
      position:absolute;
      bottom:4px;
      left:50%;
      transform:translateX(-50%);
      color:#000;
      font-size:10px;
      font-weight:700;
      pointer-events:none;
    }
    .coord-files,
    .coord-ranks{
      pointer-events: none;
      color: rgba(255,255,255,.8);
      font-weight: 700;
      font-size: clamp(11px, 2.5vw, 14px);
    }
    .coord-files{
      grid-area: files;
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      text-align: center;
      padding: 0 4px 0 0;
    }
    .coord-ranks{
      grid-area: ranks;
      display:grid;
      grid-template-rows: repeat(8, 1fr);
      align-items: center;
      justify-items: end;
      width: 26px;
      padding-right: 4px;
      align-self: stretch;
      height: 100%;
    }
    .sq{
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: clamp(22px, 6vw, 44px);
      line-height: 1;
      aspect-ratio: 1 / 1;
      overflow: hidden;
      min-width: 0;
      min-height: 0;
      position: relative;
    }
    .light{ background:var(--light); }
    .dark{ background:var(--dark); }
    .sq.king-check::after{
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 50% 50%, rgba(255,64,64,.45), rgba(255,64,64,0));
      box-shadow: inset 0 0 0 1px rgba(255,64,64,.25), 0 0 12px rgba(255,64,64,.55);
      pointer-events: none;
      z-index: 0;
    }
    .piece{
      width: auto;
      height: auto;
      display:flex;
      align-items:center;
      justify-content:center;
      line-height: 1;
      pointer-events: none;
      position: relative;
      z-index: 1;
    }
    .piece img{ width: 140.712%; height: 140.712%; display:block; user-select:none; -webkit-user-select:none; }
    .sq.selected{ outline: 3px solid rgba(255,255,255,.4); outline-offset:-3px; }
    .sq .move-dot{
      position:absolute;
      width:18%;
      height:18%;
      border-radius:50%;
      background:rgba(0,0,0,.35);
      pointer-events:none;
    }
    .sq.light .move-dot{ background: rgba(0,0,0,.5); }
    .sq.dark .move-dot{ background: rgba(255,255,255,.5); }
    .sq .capture-ring{
      position: absolute;
      inset: 8%;
      border-radius: 10px;
      pointer-events: none;
      z-index: 0;
    }
    .history-bar{
      width:100%;
      background: linear-gradient(180deg, rgba(255,255,255,.06) 0%, rgba(255,255,255,.03) 100%);
      border:1px solid var(--border);
      border-radius:12px;
      padding:12px 12px 10px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .history-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      width:100%;
    }
    .history-head .status{ margin:2px 0 0 0; font-size:12px; opacity:.7; }
    .history-controls{
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      transform: none;
      width: 100%;
      display:flex;
      gap:12px;
      justify-content:space-between;
      align-items:center;
      padding:12px 12px calc(12px + env(safe-area-inset-bottom));
      border-radius:16px 16px 0 0;
      border:1px solid var(--border);
      background: rgba(0,0,0,.7);
      box-shadow: 0 18px 46px rgba(0,0,0,.55);
      backdrop-filter: blur(12px);
      z-index:5000;
    }
    .history-btn{
      flex:1;
      min-width:0;
      height:68px;
      display:grid;
      place-items:center;
      padding:0;
      border-radius:14px;
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,.14) 0%, rgba(255,255,255,.04) 100%);
      color:var(--text);
      cursor:pointer;
      font-size: clamp(20px, 5vw, 26px);
      transition: background .15s ease, transform .1s ease, box-shadow .15s ease;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      backdrop-filter: inherit;
    }
    .history-btn .iconify{
      font-size: clamp(22px, 6vw, 30px);
      color: currentColor;
    }
    .history-btn:active{ transform: translateY(1px); }
    .history-btn:disabled{ opacity:.45; cursor:not-allowed; }
    @media (max-width: 520px){
      .history-controls{
        padding: 10px 10px calc(10px + env(safe-area-inset-bottom));
        gap: 10px;
      }
      .history-btn{ height:60px; font-size: clamp(18px, 6vw, 24px); }
    }
    .priority-wrap{
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:stretch;
      text-align:left;
      border:none;
      padding:0;
      background:none;
      width:100%;
    }
    .priority-title{
      font-weight:800;
      font-size:18px;
      opacity:1;
      letter-spacing:0.3px;
    }
    .priority-moves{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap:12px;
      width:100%;
    }
    .priority-item{
      display:flex;
      flex-direction:column;
      gap:8px;
      padding:14px;
      border-radius:12px;
      background: linear-gradient(180deg, rgba(255,255,255,.04) 0%, rgba(255,255,255,.01) 100%);
      border:1px solid var(--border);
      cursor:pointer;
      transition: border-color .12s ease, box-shadow .12s ease, transform .08s ease;
      outline:none;
    }
    .priority-item:focus-visible{ box-shadow: 0 0 0 3px rgba(207,224,247,.25); border-color: rgba(207,224,247,.6); }
    .priority-item:active{ transform: translateY(1px); }
    .priority-item.is-empty{ cursor: default; }
    .priority-head{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap: wrap;
    }
    .priority-piece-icon{
      display:grid;
      place-items:center;
      width:38px;
      height:38px;
      border-radius:10px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      color:#cfe0f7;
      font-size:28px;
      flex-shrink:0;
    }
    .priority-move{
      font-weight:800;
      letter-spacing:0.3px;
      font-size:18px;
      display:flex;
      align-items:center;
      gap:6px;
    }
    .priority-index{ color:#cfe0f7; }
    .priority-score{
      margin-left:auto;
      padding:4px 8px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.08);
      font-weight:700;
      font-size:13px;
    }
    .priority-pv{
      font-size:14px;
      opacity:.9;
      line-height:1.4;
    }
    .history-body{
      display:grid;
      gap:10px;
      max-height:360px;
      overflow-y:auto;
      padding-right:6px;
      scroll-behavior:smooth;
    }
    .history-body::-webkit-scrollbar{ width:8px; }
    .history-body::-webkit-scrollbar-thumb{ background:rgba(255,255,255,.2); border-radius:999px; }
    .history-body::-webkit-scrollbar-track{ background:rgba(255,255,255,.06); }
    .analysis-history{
      display:flex;
      flex-direction:column;
      gap:6px;
      padding:4px 4px 6px 0;
      margin:0;
      width:100%;
    }
    .move-row{
      display:grid;
      grid-template-columns: 42px 1fr 1fr;
      align-items:stretch;
      background: rgba(0,0,0,.35);
      border:1px solid var(--border);
      border-radius:10px;
      overflow:hidden;
    }
    .board-meta{
      display:flex;
      flex-direction:column;
      align-items:flex-start;
      justify-content:flex-start;
      gap:8px;
      width:100%;
      text-align:left;
    }
    .analysis-status{
      margin:0;
      padding:0;
      border-radius:0;
      border:none;
      background:none;
      font-weight:600;
    }
    .move-num{
      display:grid;
      place-items:center;
      font-weight:700;
      font-size:14px;
      background:rgba(255,255,255,.04);
      border-right:1px solid var(--border);
      min-width:42px;
    }
    .move-col{
      padding:8px 10px;
      font-weight:600;
      display:flex;
      align-items:center;
      min-height:36px;
      position:relative;
    }
    .move-col::after{
      content:'';
      position:absolute;
      inset:0;
      background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.02));
      opacity:0;
      transition:opacity .12s ease;
      z-index:0;
    }
    .move-col span{ position:relative; z-index:1; }
    .move-col.is-active::after{ opacity:1; }
    .move-col.is-empty{ opacity:.45; font-weight:500; }
    .history-empty{ opacity:.7; font-size:14px; padding:4px 0 2px; }
    .promotion-overlay{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      padding: 20px;
    }
    .promotion-overlay.active{ display:flex; }
    .promotion-dialog{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 16px;
      max-width: 320px;
      width: 100%;
    }
    .promotion-title{ margin: 0 0 12px 0; font-weight: 700; }
    .promotion-grid{
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 10px;
    }
    .promotion-btn{
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 12px;
      color: var(--text);
      cursor: pointer;
    }
    .promotion-btn:active{ transform: translateY(1px); }
    .promotion-icon{ width: 36px; height: 36px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top-bar">
      <h2>Stockfish анализ позиции</h2>
      <a class="btn" href="index.html">Назад</a>
    </div>

    <div class="layout">
      <div class="panel board-panel">
        <div class="board-wrapper">
          <div class="eval-bar" aria-hidden="true">
            <div class="eval-fill" id="evalFill"></div>
            <div class="eval-label" id="evalLabel">0.0</div>
          </div>
          <div id="ranksLeft" class="coord-ranks"></div>
          <div id="board" class="board" aria-label="Доска для визуализации позиции">
            <svg id="boardArrows" class="board-arrows" viewBox="0 0 800 800"></svg>
          <div id="boardSquares" class="board-squares"></div>
          </div>
          <div id="filesBottom" class="coord-files"></div>
        </div>
        <div class="board-meta">
          <div class="priority-wrap" id="boardPriorityWrap">
            <div class="priority-title">Приоритетные ходы</div>
            <div id="boardPriorityMoves" class="priority-moves"></div>
          </div>
          <div class="analysis-status" id="analysisStatus">Готовимся к анализу...</div>
        </div>
        <div class="status" id="boardStatus">Выберите фигуру текущего цвета, чтобы сделать ход.</div>
        <div class="history-bar">
          <div class="history-head">
            <div>
              <strong>Новые записи</strong>
            </div>
            <div class="history-controls" aria-label="Управление историей">
              <button class="history-btn" id="historyFirstBtn" title="К началу" aria-label="К началу">
                <span class="iconify" data-icon="mdi:page-first" aria-hidden="true"></span>
              </button>
              <button class="history-btn" id="historyUpBtn" title="Назад" aria-label="Шаг назад">
                <span class="iconify" data-icon="mdi:chevron-left" aria-hidden="true"></span>
              </button>
              <button class="history-btn" id="historyDownBtn" title="Вперёд" aria-label="Шаг вперёд">
                <span class="iconify" data-icon="mdi:chevron-right" aria-hidden="true"></span>
              </button>
              <button class="history-btn" id="historyLastBtn" title="В конец" aria-label="В конец">
                <span class="iconify" data-icon="mdi:page-last" aria-hidden="true"></span>
              </button>
            </div>
          </div>
          <div class="history-body">
            <div id="analysisHistory" class="analysis-history" aria-live="polite" aria-atomic="true"></div>
            <div id="historyEmpty" class="history-empty">Начните делать ходы, и они появятся здесь.</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="promotionOverlay" class="promotion-overlay" role="dialog" aria-modal="true" aria-label="Выбор фигуры для превращения">
    <div class="promotion-dialog">
      <div class="promotion-title">Превратить пешку в:</div>
      <div class="promotion-grid">
        <button class="promotion-btn" data-piece="q">
          <img class="promotion-icon" alt="" src="icone/white/Chess_qlt45.svg" />
          <span>Ферзь</span>
        </button>
        <button class="promotion-btn" data-piece="r">
          <img class="promotion-icon" alt="" src="icone/white/Chess_rlt45.svg" />
          <span>Ладья</span>
        </button>
        <button class="promotion-btn" data-piece="b">
          <img class="promotion-icon" alt="" src="icone/white/Chess_blt45.svg" />
          <span>Слон</span>
        </button>
        <button class="promotion-btn" data-piece="n">
          <img class="promotion-icon" alt="" src="icone/white/Chess_nlt45.svg" />
          <span>Конь</span>
        </button>
      </div>
    </div>
  </div>

  <script>
    const params = new URLSearchParams(window.location.search);
    const initialFen = params.get('fen');
    const HISTORY_STORAGE_KEY = 'chess-miniapp-history';

    const files = ['a','b','c','d','e','f','g','h'];
    const ranks = ['8','7','6','5','4','3','2','1'];

    const WHITE_SVG = {
      P: 'icone/white/Chess_plt45.svg',
      N: 'icone/white/Chess_nlt45.svg',
      B: 'icone/white/Chess_blt45.svg',
      R: 'icone/white/Chess_rlt45.svg',
      Q: 'icone/white/Chess_qlt45.svg',
      K: 'icone/white/Chess_klt45.svg'
    };

    const BLACK_SVG = {
      p: 'icone/black/Chess_pdt45.svg',
      n: 'icone/black/Chess_ndt45.svg',
      b: 'icone/black/Chess_bdt45.svg',
      r: 'icone/black/Chess_rdt45.svg',
      q: 'icone/black/Chess_qdt45.svg',
      k: 'icone/black/Chess_kdt45.svg'
    };

    const fenTextEl = document.getElementById('fenText');
    const statusEl = document.getElementById('engineStatus');
    const analysisListEl = document.getElementById('analysisList');
    const analysisHistoryEl = document.getElementById('analysisHistory');
    const historyEmptyEl = document.getElementById('historyEmpty');
    const historyBodyEl = document.querySelector('.history-body');
    const historyFirstBtn = document.getElementById('historyFirstBtn');
    const historyUpBtn = document.getElementById('historyUpBtn');
    const historyDownBtn = document.getElementById('historyDownBtn');
    const historyLastBtn = document.getElementById('historyLastBtn');
    const refreshBtn = document.getElementById('refreshBtn');
    const boardSquaresEl = document.getElementById('boardSquares');
    const arrowsEl = document.getElementById('boardArrows');
    const boardPriorityWrapEl = document.getElementById('boardPriorityWrap');
    const boardPriorityMovesEl = document.getElementById('boardPriorityMoves');
    const analysisStatusEl = document.getElementById('analysisStatus');
    const boardStatusEl = document.getElementById('boardStatus');
    const filesBottomEl = document.getElementById('filesBottom');
    const ranksLeftEl = document.getElementById('ranksLeft');
    const evalFillEl = document.getElementById('evalFill');
    const evalLabelEl = document.getElementById('evalLabel');
    const promotionOverlay = document.getElementById('promotionOverlay');
    const promotionButtons = Array.from(document.querySelectorAll('.promotion-btn'));
    const priorityTargets = [
      { wrap: boardPriorityWrapEl, list: boardPriorityMovesEl }
    ].filter((item) => item.wrap && item.list);

    const ANALYZE_URL = 'http://127.0.0.1:8000/analyze';
    const CACHE_TTL_MS = 10_000;
    const analyzeCache = new Map();
    const analysisHistory = [];
    const historyPlies = [];
    const moveSound = new Audio('audio/chess-move.ogg');
    const checkSound = new Audio('audio/chess-check.ogg');
    const evaluationPerspective = getFenActiveColor(initialFen) || 'w';
    let historyCursor = -1;
    let currentFen = initialFen;
    let boardState = [];
    let activeColor = 'w';
    let fullmove = 1;
    let castlingRights = '-';
    let enPassantTarget = '-';
    let selectedSq = null;
    let possibleMoves = [];
    let promotionState = null;

    function setPromotionIcons(color){
      const iconMap = color === 'w' ? WHITE_SVG : BLACK_SVG;
      promotionButtons.forEach((btn) => {
        const code = btn.dataset.piece;
        const key = color === 'w' ? code.toUpperCase() : code;
        const img = btn.querySelector('img');
        if (img) img.src = iconMap[key] || '';
      });
    }

    function openPromotionDialog(color){
      if (!promotionOverlay) return;
      setPromotionIcons(color);
      promotionOverlay.classList.add('active');
    }

    function closePromotionDialog(){
      if (!promotionOverlay) return;
      promotionOverlay.classList.remove('active');
    }

    function setAnalysisStatus(text){
      if (statusEl) statusEl.textContent = text;
      if (analysisStatusEl) analysisStatusEl.textContent = text;
    }

    function getFenActiveColor(fenStr){
      return fenStr?.split(' ')[1] === 'b' ? 'b' : 'w';
    }

    function normalizeScore(line, perspective){
      const side = (perspective || evaluationPerspective || activeColor) === 'b' ? 'b' : 'w';
      if (!line) return { cp: 0, label: '0.0', mate: null };

      const rawMate = line?.mate;
      if (rawMate !== undefined && rawMate !== null){
        const signedMate = side === 'w' ? rawMate : -rawMate;
        const cpEquivalent = signedMate > 0 ? 900 : -900;
        const mateLabelPrefix = signedMate > 0 ? '' : '-';
        return { cp: cpEquivalent, label: `${mateLabelPrefix}M${Math.abs(signedMate)}`, mate: signedMate };
      }

      const rawCp = Number(line?.score_cp);
      if (Number.isNaN(rawCp)) return { cp: 0, label: '0.0', mate: null };
      const signedCp = side === 'w' ? rawCp : -rawCp;
      return { cp: signedCp, label: (signedCp / 100).toFixed(2), mate: null };
    }

    function renderAnalysisLines(lines = [], { fromCache = false, perspective = null } = {}){
      const viewColor = perspective || evaluationPerspective || getFenActiveColor(currentFen);
      if (analysisListEl){
        analysisListEl.innerHTML = '';
      }
      if (!lines.length){
        if (analysisListEl){
          const empty = document.createElement('li');
          empty.textContent = 'Нет данных анализа';
          analysisListEl.appendChild(empty);
        }
        updateArrow(null);
        updateEvalBar(null, viewColor);
        return;
      }
      if (analysisListEl){
        lines.slice(0, 3).forEach((line, idx) => {
          const li = document.createElement('li');
          const title = document.createElement('div');
          title.innerHTML = `<strong>#${idx + 1}</strong> ${line.best_move_uci || '—'}`;
          const { label, mate } = normalizeScore(line, viewColor);
          const scoreText = mate !== null
            ? `Мат за ${Math.abs(mate)} (${mate > 0 ? 'белые' : 'чёрные'})`
            : `${label} cp`;
          const score = document.createElement('div');
          score.innerHTML = `<span class="mono">${scoreText}</span>`;
          const pv = document.createElement('div');
          pv.textContent = line.pv_san || '—';
          pv.classList.add('mono');
          li.appendChild(title);
          li.appendChild(score);
          li.appendChild(pv);
          analysisListEl.appendChild(li);
        });
      }
      setAnalysisStatus(fromCache ? 'Показан кешированный анализ (до 10 секунд).' : 'Анализ обновлён.');
      updatePriorityMoves(lines, viewColor);
      updateArrow(lines?.[0]);
      updateEvalBar(lines?.[0], viewColor);
    }

    function normalizeTokenToString(token){
      if (token === undefined || token === null) return '';
      if (typeof token === 'string') return token;
      if (Array.isArray(token)) return token.join(' ');
      return String(token);
    }

    function getPieceIconName(token = ''){
      const clean = normalizeTokenToString(token).trim();
      if (!clean) return 'mdi:chess-pawn';
      if (/^o-o/i.test(clean)) return 'mdi:castle';
      const first = clean[0].toUpperCase();
      switch (first){
        case 'K': return 'mdi:chess-king';
        case 'Q': return 'mdi:chess-queen';
        case 'R': return 'mdi:chess-rook';
        case 'B': return 'mdi:chess-bishop';
        case 'N': return 'mdi:chess-knight';
        default: return 'mdi:chess-pawn';
      }
    }

    function createPieceIcon(iconName){
      const span = document.createElement('span');
      span.className = 'iconify priority-piece-icon';
      span.dataset.icon = iconName;
      span.setAttribute('aria-hidden', 'true');
      return span;
    }

    function formatPriorityScore(line, perspective){
      const { label, mate } = normalizeScore(line, perspective);
      if (mate !== null){
        const side = mate > 0 ? 'белых' : 'чёрных';
        return `Мат за ${Math.abs(mate)} (${side})`;
      }
      return `${label} cp`;
    }

    function parsePromotionFromUci(uci = ''){
      if (!uci || uci.length < 5) return null;
      return uci[4];
    }

    function applyPriorityMove(line){
      if (!line || !line.best_move_uci){
        setBoardStatus('Нет данных для приоритетного хода.');
        return;
      }
      const coords = uciToCoords(line.best_move_uci);
      if (!coords){
        setBoardStatus('Некорректный формат приоритетного хода.');
        return;
      }
      const { from, to } = coords;
      const movingPiece = getPieceAt(from);
      if (!movingPiece){
        setBoardStatus('На исходной клетке нет фигуры для приоритетного хода.');
        return;
      }
      if (getPieceColor(movingPiece) !== activeColor){
        setBoardStatus('Сейчас ход другого цвета.');
        return;
      }
      if (!isLegalPieceMove(movingPiece, from, to, boardState)){
        setBoardStatus('Приоритетный ход неразрешён правилами.');
        return;
      }
      if (wouldLeaveKingInCheck(from, to, movingPiece)){
        setBoardStatus('Приоритетный ход оставляет короля под боем.');
        return;
      }
      const capturedPiece = getPieceAt(to);
      const promotionPiece = parsePromotionFromUci(line.best_move_uci);
      const scoreLabel = formatPriorityScore(line, evaluationPerspective || activeColor);
      finalizeMove({ fromSquare: from, toSquare: to, movingPiece, capturedPiece, promotionPiece });
      setBoardStatus(`Выполнен приоритетный ход (${scoreLabel}).`);
    }

    function updatePriorityMoves(lines = [], perspective = null){
      const viewColor = perspective || evaluationPerspective || getFenActiveColor(currentFen);
      priorityTargets.forEach(({ list }) => {
        list.innerHTML = '';
      });
      const top = lines.slice(0,3);
      if (!top.length){
        priorityTargets.forEach(({ list }) => {
          const empty = document.createElement('div');
          empty.className = 'priority-item mono is-empty';
          empty.textContent = 'Нет приоритетных ходов';
          list.appendChild(empty);
        });
        return;
      }
      top.forEach((line, idx) => {
        priorityTargets.forEach(({ list }) => {
          const item = document.createElement('div');
          item.className = 'priority-item';

          const head = document.createElement('div');
          head.className = 'priority-head';
          const icon = createPieceIcon(getPieceIconName(line.pv_san || line.best_move_uci || ''));
          const title = document.createElement('div');
          title.className = 'priority-move';
          const index = document.createElement('span');
          index.className = 'priority-index';
          index.textContent = `${idx + 1}.`;
          const moveText = document.createElement('span');
          moveText.className = 'priority-move-text mono';
          moveText.textContent = line.best_move_uci || '—';
          title.appendChild(index);
          title.appendChild(moveText);
          head.appendChild(icon);
          head.appendChild(title);

          const score = document.createElement('div');
          score.className = 'priority-score mono';
          score.textContent = formatPriorityScore(line, viewColor);
          head.appendChild(score);

          const pv = document.createElement('div');
          pv.className = 'priority-pv mono';
          pv.textContent = line.pv_san || '—';

          item.appendChild(head);
          item.appendChild(pv);
          item.setAttribute('role', 'button');
          item.setAttribute('aria-label', `Сделать ход ${line.best_move_uci || ''}`);
          item.tabIndex = 0;
          item.addEventListener('click', () => applyPriorityMove(line));
          item.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' || event.key === ' '){
              event.preventDefault();
              applyPriorityMove(line);
            }
          });
          list.appendChild(item);
        });
      });
    }

    function fenToBoard(fenStr){
      const placement = (fenStr || '').split(' ')[0];
      if (!placement) return Array.from({ length: 8 }, () => Array(8).fill(''));
      const rows = placement.split('/');
      if (rows.length !== 8) return Array.from({ length: 8 }, () => Array(8).fill(''));
      const board = [];
      for (const row of rows){
        const cols = [];
        for (const ch of row){
          if (/[1-8]/.test(ch)){
            for (let i = 0; i < Number(ch); i++) cols.push('');
          } else {
            cols.push(ch);
          }
        }
        board.push(cols);
      }
      return board;
    }

    function parseFenState(fenStr){
      const parts = (fenStr || '').split(' ');
      const board = fenToBoard(fenStr);
      const active = parts[1] === 'b' ? 'b' : 'w';
      const moveNumber = Number(parts[5]) || 1;
      const rights = parts[2] || '-';
      const ep = parts[3] || '-';
      return { board, active, fullmove: moveNumber, rights, ep };
    }

    function boardToFen(board, active = 'w', moveNumber = 1){
      const rows = board.map((row) => {
        let res = '';
        let empty = 0;
        for (const cell of row){
          if (!cell){
            empty++;
          } else {
            if (empty){ res += empty; empty = 0; }
            res += cell;
          }
        }
        if (empty) res += empty;
        return res;
      });
      const placement = rows.join('/');
      const rights = castlingRights && castlingRights !== '' ? castlingRights : '-';
      const ep = enPassantTarget && enPassantTarget !== '' ? enPassantTarget : '-';
      return `${placement} ${active} ${rights} ${ep} 0 ${moveNumber}`;
    }

    function renderBoardCoords(){
      if (!filesBottomEl || !ranksLeftEl) return;
      filesBottomEl.innerHTML = '';
      ranksLeftEl.innerHTML = '';
      files.forEach((file) => {
        const span = document.createElement('span');
        span.textContent = file;
        filesBottomEl.appendChild(span);
      });
      ranks.forEach((rank) => {
        const span = document.createElement('span');
        span.textContent = rank;
        ranksLeftEl.appendChild(span);
      });
    }

    function renderBoardFromFen(fenStr){
      if (!boardSquaresEl) return;
      boardSquaresEl.innerHTML = '';
      const grid = fenToBoard(fenStr);
      const whiteKingPos = findKing('w', boardState);
      const blackKingPos = findKing('b', boardState);
      const whiteInCheck = !!(whiteKingPos && isKingInCheck('w'));
      const blackInCheck = !!(blackKingPos && isKingInCheck('b'));
      const selectedPiece = selectedSq ? getPieceAt(selectedSq) : '';
      grid.forEach((row, rowIdx) => {
        row.forEach((cell, colIdx) => {
          const sq = document.createElement('div');
          const isLight = (rowIdx + colIdx) % 2 === 0;
          const coord = `${files[colIdx]}${ranks[rowIdx]}`;
          sq.className = `sq ${isLight ? 'light' : 'dark'}`;
          sq.dataset.square = coord;
          sq.addEventListener('click', () => handleSquareClick(coord));
          if ((whiteInCheck && whiteKingPos?.rankIdx === rowIdx && whiteKingPos?.fileIdx === colIdx)
            || (blackInCheck && blackKingPos?.rankIdx === rowIdx && blackKingPos?.fileIdx === colIdx)){
            sq.classList.add('king-check');
          }
          if (cell){
            const piece = document.createElement('div');
            const img = document.createElement('img');
            const isWhite = /[PNBRQK]/.test(cell);
            const src = isWhite ? WHITE_SVG[cell] : BLACK_SVG[cell];
            if (src) img.src = src;
            piece.className = `piece ${isWhite ? 'white' : 'black'}`;
            piece.appendChild(img);
            sq.appendChild(piece);
          }
          if (possibleMoves.includes(coord)){
            const targetPiece = boardState[rowIdx]?.[colIdx] || '';
            if (targetPiece && selectedPiece && getPieceColor(targetPiece) !== getPieceColor(selectedPiece)){
              const ring = document.createElement('div');
              ring.className = 'capture-ring';
              sq.appendChild(ring);
            } else {
              const dot = document.createElement('div');
              dot.className = 'move-dot';
              sq.appendChild(dot);
            }
          }
          boardSquaresEl.appendChild(sq);
        });
      });
      if (selectedSq){
        const sqEl = boardSquaresEl.querySelector(`[data-square="${selectedSq}"]`);
        if (sqEl) sqEl.classList.add('selected');
      }
    }

    function uciToCoords(uci){
      if (!uci || uci.length < 4) return null;
      return { from: uci.slice(0,2), to: uci.slice(2,4) };
    }

    function updateArrow(line){
      if (!arrowsEl) return;
      arrowsEl.innerHTML = '';
      const move = line?.best_move_uci;
      const coords = uciToCoords(move);
      if (!coords) return;
      const startFile = files.indexOf(coords.from[0]);
      const startRank = ranks.indexOf(coords.from[1]);
      const endFile = files.indexOf(coords.to[0]);
      const endRank = ranks.indexOf(coords.to[1]);
      if (startFile < 0 || startRank < 0 || endFile < 0 || endRank < 0) return;
      const cell = 100;
      const offset = cell / 2;
      const x1 = startFile * cell + offset;
      const y1 = startRank * cell + offset;
      const x2 = endFile * cell + offset;
      const y2 = endRank * cell + offset;

      const path = document.createElementNS('http://www.w3.org/2000/svg','line');
      path.setAttribute('x1', x1);
      path.setAttribute('y1', y1);
      path.setAttribute('x2', x2);
      path.setAttribute('y2', y2);
      path.classList.add('arrow-path');

      const marker = document.createElementNS('http://www.w3.org/2000/svg','polygon');
      const angle = Math.atan2(y2 - y1, x2 - x1);
      const headLength = 22;
      const headWidth = 16;
      const hx = x2 - Math.cos(angle) * headLength;
      const hy = y2 - Math.sin(angle) * headLength;
      const p1x = hx + Math.cos(angle + Math.PI / 2) * headWidth;
      const p1y = hy + Math.sin(angle + Math.PI / 2) * headWidth;
      const p2x = hx + Math.cos(angle - Math.PI / 2) * headWidth;
      const p2y = hy + Math.sin(angle - Math.PI / 2) * headWidth;
      marker.setAttribute('points', `${x2},${y2} ${p1x},${p1y} ${p2x},${p2y}`);
      marker.classList.add('arrow-head');

      arrowsEl.appendChild(path);
      arrowsEl.appendChild(marker);
    }

    function updateEvalBar(line, perspective = null){
      if (!evalFillEl || !evalLabelEl) return;
      const viewColor = perspective || evaluationPerspective || getFenActiveColor(currentFen);
      const { cp, label } = normalizeScore(line, viewColor);
      const normalized = 1 / (1 + Math.exp(-cp / 200));
      const percent = Math.round(normalized * 100);
      evalFillEl.style.height = `${percent}%`;
      evalLabelEl.textContent = label;
    }

    function extractErrorDetail(errObj, fallback){
      if (errObj && typeof errObj === 'object' && 'detail' in errObj){
        if (typeof errObj.detail === 'string') return errObj.detail;
        try { return JSON.stringify(errObj.detail); } catch (_) {}
      }
      return fallback || 'Неизвестная ошибка';
    }

    async function fetchJson(url, payload){
      const response = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      const text = await response.text();
      let data = null;
      try { data = text ? JSON.parse(text) : null; } catch (_) { data = null; }
      if (!response.ok){
        const detail = extractErrorDetail(data, text || `${response.status} ${response.statusText}`);
        throw new Error(detail);
      }
      return data;
    }

    async function analyzePosition(options = {}){
      const {
        force = false,
        attachToHistory = true,
        targetRowIndex = null
      } = typeof options === 'object' && options !== null ? options : {};
      if (!currentFen){
        setAnalysisStatus('FEN не передан. Вернитесь на главную и откройте анализ заново.');
        return;
      }

      const targetRow = Number.isInteger(targetRowIndex) ? analysisHistory[targetRowIndex] : null;
      const existingLines = targetRow?.lines || [];
      if (existingLines.length && !force){
        renderAnalysisLines(existingLines, { fromCache: true });
        return;
      }

      const cached = analyzeCache.get(currentFen);
      const now = Date.now();
      const cacheValid = !force && cached && now - cached.timestamp < CACHE_TTL_MS;
      const cachedLines = cacheValid ? (cached.data?.lines || cached.data?.analysis || []) : [];
      if (cacheValid && cachedLines.length){
        if (targetRow){
          targetRow.lines = cachedLines.slice(0, 3);
        }
        renderAnalysisLines(cachedLines, { fromCache: true });
        return;
      }

      setAnalysisStatus('Запрашиваем анализ у сервера...');
      if (refreshBtn) refreshBtn.disabled = true;
      try {
        const payload = { fen: currentFen, movetime_ms: 250, multipv: 3, side: 'turn' };
        const data = await fetchJson(ANALYZE_URL, payload);
        const lines = data?.lines || data?.analysis || [];
        analyzeCache.set(currentFen, { timestamp: now, data });
        if (targetRow){
          targetRow.lines = lines.slice(0, 3);
        }
        renderAnalysisLines(lines, { fromCache: false });
        if (attachToHistory){
          pushAnalysisHistory(currentFen, lines);
        }
      } catch (err){
        setAnalysisStatus(`Ошибка анализа: ${err.message}`);
        if (analysisListEl) analysisListEl.innerHTML = '';
      } finally {
        if (refreshBtn) refreshBtn.disabled = false;
      }
    }

    function readStoredMoveHistory(){
      try {
        const raw = localStorage.getItem(HISTORY_STORAGE_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch (err){
        console.warn('Не удалось прочитать историю ходов', err);
        return null;
      }
    }

    function rebuildHistoryPlies({ preserveCursor = false } = {}){
      const prevKey = preserveCursor && historyCursor >= 0 && historyPlies[historyCursor]
        ? `${historyPlies[historyCursor].rowIndex}-${historyPlies[historyCursor].side}`
        : null;
      historyPlies.length = 0;
      analysisHistory.forEach((item, idx) => {
        const whiteText = item.moves?.white || '—';
        const blackText = item.moves?.black || '—';
        if (whiteText !== '—' && item.fens?.white){
          historyPlies.push({ rowIndex: idx, side: 'white', fen: item.fens.white });
        }
        if (blackText !== '—' && item.fens?.black){
          historyPlies.push({ rowIndex: idx, side: 'black', fen: item.fens.black });
        }
      });
      if (!historyPlies.length){
        historyCursor = -1;
        return;
      }
      if (prevKey){
        const newIdx = historyPlies.findIndex((ply) => `${ply.rowIndex}-${ply.side}` === prevKey);
        if (newIdx !== -1){
          historyCursor = newIdx;
          return;
        }
      }
      historyCursor = Math.min(historyCursor, historyPlies.length - 1);
      if (historyCursor === -1 || Number.isNaN(historyCursor)){
        historyCursor = historyPlies.length - 1;
      }
    }

    function hydrateHistoryFromStorage(){
      const stored = readStoredMoveHistory();
      if (!stored || !Array.isArray(stored.moves) || !stored.moves.length) return;
      const startFen = stored.startFen || currentFen || initialFen;
      analysisHistory.length = 0;
      historyCursor = -1;
      let lastFen = startFen;

      stored.moves.forEach((move, idx) => {
        const text = move?.san || move?.uci || '—';
        const fenForMove = move?.fen || lastFen;
        const rowIdx = Math.floor(idx / 2);
        if (!analysisHistory[rowIdx]){
          analysisHistory[rowIdx] = {
            fen: lastFen,
            createdAt: move?.createdAt ? new Date(move.createdAt) : new Date(),
            lines: [],
            moves: { white: '—', black: '—' },
            fens: { white: null, black: null },
            active: lastFen?.split(' ')[1] === 'b' ? 'b' : 'w'
          };
        }
        if (idx % 2 === 0){
          analysisHistory[rowIdx].moves.white = text;
          analysisHistory[rowIdx].fens.white = fenForMove;
        } else {
          analysisHistory[rowIdx].moves.black = text;
          analysisHistory[rowIdx].fens.black = fenForMove;
        }
        analysisHistory[rowIdx].fen = fenForMove;
        analysisHistory[rowIdx].active = fenForMove?.split(' ')[1] === 'b' ? 'b' : 'w';
        lastFen = fenForMove;
      });

      rebuildHistoryPlies();
      historyCursor = historyPlies.length ? historyPlies.length - 1 : -1;
      const lastCursorFen = historyCursor >= 0 ? historyPlies[historyCursor]?.fen : null;
      currentFen = lastCursorFen || lastFen || currentFen;
      const parsed = parseFenState(currentFen);
      boardState = parsed.board;
      activeColor = parsed.active;
      fullmove = parsed.fullmove;
      castlingRights = parsed.rights || '-';
      enPassantTarget = parsed.ep || '-';
      if (fenTextEl) fenTextEl.textContent = currentFen || '—';
      renderBoardFromFen(currentFen);
      renderHistory({ scrollToCursor: true });
      loadHistoryPosition(historyCursor);
    }

    function renderHistory(options = {}){
      const { scrollToCursor = false } = options;
      if (!analysisHistoryEl || !historyEmptyEl) return;
      analysisHistoryEl.innerHTML = '';
      updateHistoryControlsEnabled();
      if (!historyPlies.length || !analysisHistory.length){
        historyEmptyEl.style.display = 'block';
        return;
      }
      historyEmptyEl.style.display = 'none';
      if (historyCursor === -1 && historyPlies.length){
        historyCursor = historyPlies.length - 1;
      }
      historyCursor = Math.min(historyCursor, historyPlies.length - 1);
      const currentPly = historyCursor >= 0 ? historyPlies[historyCursor] : null;
      analysisHistory.forEach((item, idx) => {
        const row = document.createElement('div');
        row.className = 'move-row';
        const moveNum = document.createElement('div');
        moveNum.className = 'move-num';
        moveNum.textContent = idx + 1;
        const whiteMove = document.createElement('div');
        const blackMove = document.createElement('div');
        whiteMove.className = 'move-col';
        blackMove.className = 'move-col';
        const white = item.moves?.white || '—';
        const black = item.moves?.black || '—';
        whiteMove.innerHTML = `<span>${white}</span>`;
        blackMove.innerHTML = `<span>${black}</span>`;
        if (white === '—') whiteMove.classList.add('is-empty');
        if (black === '—') blackMove.classList.add('is-empty');
        if (currentPly && idx === currentPly.rowIndex){
          row.classList.add('is-current');
          if (currentPly.side === 'white') whiteMove.classList.add('is-active');
          if (currentPly.side === 'black') blackMove.classList.add('is-active');
        }
        row.appendChild(moveNum);
        row.appendChild(whiteMove);
        row.appendChild(blackMove);
        analysisHistoryEl.appendChild(row);
      });
      if (scrollToCursor && currentPly && historyBodyEl){
        requestAnimationFrame(() => {
          const targetRow = analysisHistoryEl.children[currentPly.rowIndex];
          if (targetRow){
            const targetOffset = Math.max(
              targetRow.offsetTop - (historyBodyEl.clientHeight / 2) + (targetRow.clientHeight / 2),
              0
            );
            historyBodyEl.scrollTo({ top: targetOffset, behavior: 'smooth' });
          }
        });
      }
    }

    function pushAnalysisHistory(fenValue, lines){
      if (!analysisHistoryEl) return;
      const pvRaw = lines?.[0]?.pv_san;
      const pv = Array.isArray(pvRaw) ? pvRaw.join(' ') : (typeof pvRaw === 'string' ? pvRaw : '');
      const tokens = pv.split(/\s+/).filter(Boolean);
      const white = tokens[0] || '—';
      const black = tokens[1] || '—';
      const entry = {
        fen: fenValue,
        createdAt: new Date(),
        lines: lines?.slice(0,3) || [],
        moves: { white, black },
        fens: { white: null, black: null },
        active: activeColor
      };
      const lastMover = activeColor === 'w' ? 'black' : 'white';
      entry.fens[lastMover] = fenValue;
      const wasAtTail = historyCursor === -1 || historyCursor === historyPlies.length - 1;
      analysisHistory.push(entry);
      const MAX_HISTORY = 200;
      if (analysisHistory.length > MAX_HISTORY){
        const removed = analysisHistory.length - MAX_HISTORY;
        analysisHistory.splice(0, removed);
        if (historyCursor !== -1){
          historyCursor = Math.max(historyCursor - removed, 0);
        }
      }
      rebuildHistoryPlies({ preserveCursor: wasAtTail });
      if (wasAtTail || historyCursor === -1){
        historyCursor = historyPlies.length ? historyPlies.length - 1 : -1;
      }
      renderHistory({ scrollToCursor: false });
    }

    function updateHistoryControlsEnabled(){
      const disabled = !historyPlies.length;
      [historyFirstBtn, historyUpBtn, historyDownBtn, historyLastBtn].forEach((btn) => {
        if (btn) btn.disabled = disabled;
      });
    }

    function scrollHistory(where){
      if (!analysisHistoryEl || !historyPlies.length) return;
      if (historyCursor === -1) historyCursor = historyPlies.length - 1;
      if (where === 'top'){
        historyCursor = 0;
      } else if (where === 'bottom'){
        historyCursor = historyPlies.length - 1;
      } else {
        const step = where === 'up' ? -1 : 1;
        historyCursor = Math.min(Math.max(historyCursor + step, 0), historyPlies.length - 1);
      }
      renderHistory({ scrollToCursor: true });
      loadHistoryPosition(historyCursor);
    }

    function loadHistoryPosition(index){
      const ply = historyPlies[index];
      if (!ply) return;
      const row = analysisHistory[ply.rowIndex];
      const fenForPly = ply.fen || row?.fen;
      if (!fenForPly) return;
      currentFen = fenForPly;
      const parsed = parseFenState(currentFen);
      boardState = parsed.board;
      activeColor = parsed.active;
      fullmove = parsed.fullmove;
      castlingRights = parsed.rights || '-';
      enPassantTarget = parsed.ep || '-';
      renderBoardFromFen(currentFen);
      if (fenTextEl) fenTextEl.textContent = currentFen;
      setBoardStatus(`Ход ${activeColor === 'w' ? 'белых' : 'чёрных'}.`);
      const viewColor = evaluationPerspective || getFenActiveColor(currentFen);
      updateArrow(row?.lines?.[0]);
      updateEvalBar(row?.lines?.[0], viewColor);
      updatePriorityMoves(row?.lines || [], viewColor);
      renderAnalysisLines(row?.lines || [], { perspective: viewColor });
      if (!row?.lines?.length){
        analyzePosition({ attachToHistory: false, targetRowIndex: ply.rowIndex });
      }
    }

    function setBoardStatus(message){
      if (boardStatusEl) boardStatusEl.textContent = message;
    }

    function getPieceColor(piece){
      if (!piece) return null;
      return /[A-Z]/.test(piece) ? 'w' : 'b';
    }

    function isSameColor(pieceA, pieceB){
      if (!pieceA || !pieceB) return false;
      return getPieceColor(pieceA) === getPieceColor(pieceB);
    }

    function squareToIndices(square){
      const fileIdx = files.indexOf(square[0]);
      const rankIdx = ranks.indexOf(square[1]);
      return { fileIdx, rankIdx };
    }

    function isInsideBoard(rankIdx, fileIdx){
      return rankIdx >= 0 && rankIdx < 8 && fileIdx >= 0 && fileIdx < 8;
    }

    function hasCastlingRight(ch){
      if (!castlingRights || castlingRights === '-') return false;
      return castlingRights.includes(ch);
    }

    function isPathClear(board, fromRank, fromFile, toRank, toFile){
      const stepRank = Math.sign(toRank - fromRank);
      const stepFile = Math.sign(toFile - fromFile);
      let r = fromRank + stepRank;
      let f = fromFile + stepFile;
      while (r !== toRank || f !== toFile){
        if (board[r][f]) return false;
        r += stepRank;
        f += stepFile;
      }
      return true;
    }

    function isLegalPieceMove(piece, fromSquare, toSquare, board){
      if (!piece || fromSquare === toSquare) return false;
      const { fileIdx: fromFile, rankIdx: fromRank } = squareToIndices(fromSquare);
      const { fileIdx: toFile, rankIdx: toRank } = squareToIndices(toSquare);
      if (!isInsideBoard(fromRank, fromFile) || !isInsideBoard(toRank, toFile)) return false;

      const color = getPieceColor(piece);
      const target = board[toRank]?.[toFile];
      if (target && isSameColor(piece, target)) return false;

      const deltaFile = toFile - fromFile;
      const deltaRank = toRank - fromRank;
      const absFile = Math.abs(deltaFile);
      const absRank = Math.abs(deltaRank);
      const upper = piece.toUpperCase();

      if (upper === 'P'){
        const dir = color === 'w' ? -1 : 1;
        const startRank = color === 'w' ? 6 : 1;
        if (deltaFile === 0){
          if (deltaRank === dir && !target) return true;
          if (fromRank === startRank && deltaRank === 2 * dir && !target){
            const betweenRank = fromRank + dir;
            if (!board[betweenRank]?.[fromFile]) return true;
          }
        } else if (absFile === 1 && deltaRank === dir){
          if (target && !isSameColor(piece, target)) return true;
        }
        return false;
      }

      if (upper === 'N'){
        return (absFile === 1 && absRank === 2) || (absFile === 2 && absRank === 1);
      }

      if (upper === 'B'){
        return absFile === absRank && isPathClear(board, fromRank, fromFile, toRank, toFile);
      }

      if (upper === 'R'){
        return (absFile === 0 || absRank === 0) && isPathClear(board, fromRank, fromFile, toRank, toFile);
      }

      if (upper === 'Q'){
        const isDiagonal = absFile === absRank;
        const isStraight = absFile === 0 || absRank === 0;
        return (isDiagonal || isStraight) && isPathClear(board, fromRank, fromFile, toRank, toFile);
      }

      if (upper === 'K'){
        if (absFile <= 1 && absRank <= 1) return true;
        if (deltaRank === 0 && Math.abs(deltaFile) === 2){
          const homeRank = color === 'w' ? 7 : 0;
          if (fromFile !== 4 || fromRank !== homeRank) return false;
          const isKingside = deltaFile === 2;
          const rookFile = isKingside ? 7 : 0;
          const rookPiece = board[homeRank]?.[rookFile];
          if (!rookPiece || getPieceColor(rookPiece) !== color || rookPiece.toUpperCase() !== 'R') return false;
          const rightChar = color === 'w' ? (isKingside ? 'K' : 'Q') : (isKingside ? 'k' : 'q');
          if (!hasCastlingRight(rightChar)) return false;
          const pathFiles = isKingside ? [5,6] : [3,2,1];
          for (const f of pathFiles){
            if (board[homeRank]?.[f]) return false;
          }
          const kingSquares = isKingside ? [4,5,6] : [4,3,2];
          for (const f of kingSquares){
            const sq = `${files[f]}${ranks[homeRank]}`;
            if (isSquareAttacked(sq, color, board)) return false;
          }
          return true;
        }
        return false;
      }

      return false;
    }

    function findKing(color, board){
      const king = color === 'w' ? 'K' : 'k';
      for (let r = 0; r < 8; r++){
        for (let f = 0; f < 8; f++){
          if (board[r]?.[f] === king) return { rankIdx: r, fileIdx: f };
        }
      }
      return null;
    }

    function isSquareAttacked(targetSquare, color, board){
      const { fileIdx: targetFile, rankIdx: targetRank } = squareToIndices(targetSquare);
      if (!isInsideBoard(targetRank, targetFile)) return false;
      const opponentColor = color === 'w' ? 'b' : 'w';
      for (let r = 0; r < 8; r++){
        for (let f = 0; f < 8; f++){
          const piece = board[r]?.[f];
          if (!piece || getPieceColor(piece) !== opponentColor) continue;
          const upper = piece.toUpperCase();
          if (upper === 'P'){
            const dir = opponentColor === 'w' ? -1 : 1;
            if (targetRank === r + dir && Math.abs(targetFile - f) === 1) return true;
            continue;
          }
          if (upper === 'N'){
            const df = Math.abs(targetFile - f);
            const dr = Math.abs(targetRank - r);
            if ((df === 1 && dr === 2) || (df === 2 && dr === 1)) return true;
            continue;
          }
          if (upper === 'K'){
            if (Math.abs(targetFile - f) <= 1 && Math.abs(targetRank - r) <= 1) return true;
            continue;
          }
          if (upper === 'B' || upper === 'Q'){
            if (Math.abs(targetFile - f) === Math.abs(targetRank - r) && isPathClear(board, r, f, targetRank, targetFile)) return true;
          }
          if (upper === 'R' || upper === 'Q'){
            const sameFile = targetFile === f;
            const sameRank = targetRank === r;
            if ((sameFile || sameRank) && isPathClear(board, r, f, targetRank, targetFile)) return true;
          }
        }
      }
      return false;
    }

    function wouldLeaveKingInCheck(fromSquare, toSquare, piece){
      const { fileIdx: fromFile, rankIdx: fromRank } = squareToIndices(fromSquare);
      const { fileIdx: toFile, rankIdx: toRank } = squareToIndices(toSquare);
      if (!isInsideBoard(fromRank, fromFile) || !isInsideBoard(toRank, toFile)) return true;
      const simulated = boardState.map((row) => row.slice());
      simulated[toRank][toFile] = piece;
      simulated[fromRank][fromFile] = '';
      const color = getPieceColor(piece);
      const kingPos = findKing(color, simulated);
      if (!kingPos) return false;
      const kingSquare = `${files[kingPos.fileIdx]}${ranks[kingPos.rankIdx]}`;
      return isSquareAttacked(kingSquare, color, simulated);
    }

    function isKingInCheck(color){
      const kingPos = findKing(color, boardState);
      if (!kingPos) return false;
      const kingSquare = `${files[kingPos.fileIdx]}${ranks[kingPos.rankIdx]}`;
      return isSquareAttacked(kingSquare, color, boardState);
    }

    function playerHasLegalMoves(color){
      for (let r = 0; r < 8; r++){
        for (let f = 0; f < 8; f++){
          const piece = boardState[r]?.[f];
          if (!piece || getPieceColor(piece) !== color) continue;
          const fromSquare = `${files[f]}${ranks[r]}`;
          for (let tr = 0; tr < 8; tr++){
            for (let tf = 0; tf < 8; tf++){
              const toSquare = `${files[tf]}${ranks[tr]}`;
              if (!isLegalPieceMove(piece, fromSquare, toSquare, boardState)) continue;
              if (wouldLeaveKingInCheck(fromSquare, toSquare, piece)) continue;
              return true;
            }
          }
        }
      }
      return false;
    }

    function playSound(sound){
      if (!sound) return;
      try {
        sound.currentTime = 0;
        sound.play().catch(() => {});
      } catch (_) {}
    }

    function playMoveAudio(){
      const inCheck = isKingInCheck(activeColor);
      const hasMoves = playerHasLegalMoves(activeColor);
      const isMate = inCheck && !hasMoves;
      if (isMate || inCheck){
        playSound(checkSound);
      } else {
        playSound(moveSound);
      }
    }

    function updateCastlingRights(fromSquare, toSquare, movingPiece, capturedPiece){
      if (!movingPiece) return;
      const upper = movingPiece.toUpperCase();
      if (upper === 'K'){
        if (getPieceColor(movingPiece) === 'w'){
          castlingRights = castlingRights.replace(/K|Q/g, '');
        } else {
          castlingRights = castlingRights.replace(/k|q/g, '');
        }
      }
      if (upper === 'R'){
        if (fromSquare === 'h1' || toSquare === 'h1') castlingRights = castlingRights.replace(/K/g, '');
        if (fromSquare === 'a1' || toSquare === 'a1') castlingRights = castlingRights.replace(/Q/g, '');
        if (fromSquare === 'h8' || toSquare === 'h8') castlingRights = castlingRights.replace(/k/g, '');
        if (fromSquare === 'a8' || toSquare === 'a8') castlingRights = castlingRights.replace(/q/g, '');
      }
      if (capturedPiece && capturedPiece.toUpperCase() === 'R'){
        if (toSquare === 'h1') castlingRights = castlingRights.replace(/K/g, '');
        if (toSquare === 'a1') castlingRights = castlingRights.replace(/Q/g, '');
        if (toSquare === 'h8') castlingRights = castlingRights.replace(/k/g, '');
        if (toSquare === 'a8') castlingRights = castlingRights.replace(/q/g, '');
      }
      if (!castlingRights.length) castlingRights = '-';
    }

    function getPieceAt(square){
      const fileIdx = files.indexOf(square[0]);
      const rankIdx = ranks.indexOf(square[1]);
      if (fileIdx < 0 || rankIdx < 0) return '';
      return boardState[rankIdx]?.[fileIdx] || '';
    }

    function setPieceAt(square, value){
      const fileIdx = files.indexOf(square[0]);
      const rankIdx = ranks.indexOf(square[1]);
      if (fileIdx < 0 || rankIdx < 0) return;
      boardState[rankIdx][fileIdx] = value;
    }

    function calculateLegalMoves(fromSquare){
      const piece = getPieceAt(fromSquare);
      if (!piece || getPieceColor(piece) !== activeColor) return [];
      const moves = [];
      for (let r = 0; r < 8; r++){
        for (let f = 0; f < 8; f++){
          const targetSquare = `${files[f]}${ranks[r]}`;
          if (!isLegalPieceMove(piece, fromSquare, targetSquare, boardState)) continue;
          if (wouldLeaveKingInCheck(fromSquare, targetSquare, piece)) continue;
          moves.push(targetSquare);
        }
      }
      return moves;
    }

    function handleSquareClick(square){
      const piece = getPieceAt(square);
      if (selectedSq){
        if (selectedSq === square){
          selectedSq = null;
          possibleMoves = [];
          setBoardStatus('Выбор фигуры отменён.');
          renderBoardFromFen(currentFen);
          return;
        }
        const movingPiece = getPieceAt(selectedSq);
        if (!movingPiece){
          selectedSq = null;
          possibleMoves = [];
          renderBoardFromFen(currentFen);
          return;
        }
        if (getPieceColor(movingPiece) !== activeColor){
          setBoardStatus('Сейчас ход другого цвета.');
          selectedSq = null;
          possibleMoves = [];
          renderBoardFromFen(currentFen);
          return;
        }
        if (!isLegalPieceMove(movingPiece, selectedSq, square, boardState)){
          if (piece && getPieceColor(piece) === activeColor){
            selectedSq = square;
            possibleMoves = calculateLegalMoves(square);
            setBoardStatus('Выбрана другая фигура того же цвета.');
          } else {
            setBoardStatus('Такой ход не разрешён правилами.');
            possibleMoves = [];
          }
          renderBoardFromFen(currentFen);
          return;
        }
        const capturedPiece = getPieceAt(square);
        if (wouldLeaveKingInCheck(selectedSq, square, movingPiece)){
          setBoardStatus('Ход оставляет короля под боем.');
          possibleMoves = [];
          renderBoardFromFen(currentFen);
          return;
        }
        const { rankIdx: fromRank } = squareToIndices(selectedSq);
        const { rankIdx: toRank } = squareToIndices(square);
        if (movingPiece.toUpperCase() === 'P' && (toRank === 0 || toRank === 7)){
          promotionState = { fromSquare: selectedSq, toSquare: square, movingPiece };
          selectedSq = null;
          possibleMoves = [];
          renderBoardFromFen(currentFen);
          openPromotionDialog(getPieceColor(movingPiece));
          setBoardStatus('Выберите фигуру для превращения.');
          return;
        }
        finalizeMove({ fromSquare: selectedSq, toSquare: square, movingPiece, capturedPiece });
        return;
      }
      if (piece && getPieceColor(piece) === activeColor){
        selectedSq = square;
        possibleMoves = calculateLegalMoves(square);
        setBoardStatus('Выбрана фигура для хода.');
      } else if (piece){
        setBoardStatus('Сейчас ход другого цвета.');
        selectedSq = null;
        possibleMoves = [];
      } else {
        setBoardStatus('Пустая клетка. Выберите фигуру.');
        selectedSq = null;
        possibleMoves = [];
      }
      renderBoardFromFen(currentFen);
    }

    function finalizeMove({ fromSquare, toSquare, movingPiece, capturedPiece, promotionPiece = null }){
      const { fileIdx: fromFile, rankIdx: fromRank } = squareToIndices(fromSquare);
      const { fileIdx: toFile, rankIdx: toRank } = squareToIndices(toSquare);
      const deltaFile = toFile - fromFile;
      const upper = movingPiece.toUpperCase();

      if (upper === 'K' && Math.abs(deltaFile) === 2){
        const isKingside = deltaFile === 2;
        const rookFrom = isKingside
          ? (getPieceColor(movingPiece) === 'w' ? 'h1' : 'h8')
          : (getPieceColor(movingPiece) === 'w' ? 'a1' : 'a8');
        const rookTo = isKingside
          ? (getPieceColor(movingPiece) === 'w' ? 'f1' : 'f8')
          : (getPieceColor(movingPiece) === 'w' ? 'd1' : 'd8');
        const rookPiece = getPieceAt(rookFrom);
        if (rookPiece){
          setPieceAt(rookTo, rookPiece);
          setPieceAt(rookFrom, '');
        }
      }

      if (upper === 'P' && Math.abs(toRank - fromRank) === 2){
        const dir = getPieceColor(movingPiece) === 'w' ? -1 : 1;
        const epRank = fromRank + dir;
        enPassantTarget = `${files[fromFile]}${ranks[epRank]}`;
      } else {
        enPassantTarget = '-';
      }

      if (upper === 'P' && (toRank === 0 || toRank === 7)){
        const normalized = ['q','r','b','n'].includes((promotionPiece || '').toLowerCase())
          ? promotionPiece.toLowerCase()
          : 'q';
        const promoteTo = getPieceColor(movingPiece) === 'w' ? normalized.toUpperCase() : normalized;
        setPieceAt(toSquare, promoteTo);
        setPieceAt(fromSquare, '');
      } else {
        setPieceAt(toSquare, movingPiece);
        setPieceAt(fromSquare, '');
      }

      updateCastlingRights(fromSquare, toSquare, movingPiece, capturedPiece);
      selectedSq = null;
      possibleMoves = [];
      activeColor = activeColor === 'w' ? 'b' : 'w';
      if (activeColor === 'w') fullmove += 1;
      currentFen = boardToFen(boardState, activeColor, fullmove);
      if (fenTextEl) fenTextEl.textContent = currentFen;
      renderBoardFromFen(currentFen);
      playMoveAudio();
      analyzePosition({ force: true });
      setBoardStatus('Ход выполнен.');
    }

    function handlePromotionChoice(pieceCode){
      if (!promotionState) return;
      const { fromSquare, toSquare, movingPiece } = promotionState;
      const capturedPiece = getPieceAt(toSquare);
      promotionState = null;
      closePromotionDialog();
      finalizeMove({ fromSquare, toSquare, movingPiece, capturedPiece, promotionPiece: pieceCode });
    }

    function init(){
      currentFen = initialFen || '8/8/8/8/8/8/8/8 w - - 0 1';
      const parsed = parseFenState(currentFen);
      boardState = parsed.board;
      activeColor = parsed.active;
      fullmove = parsed.fullmove;
      castlingRights = parsed.rights || '-';
      enPassantTarget = parsed.ep || '-';
      setBoardStatus(`Ход ${activeColor === 'w' ? 'белых' : 'чёрных'}. Выберите фигуру.`);
      updateHistoryControlsEnabled();
      if (fenTextEl) fenTextEl.textContent = currentFen || '—';
      renderBoardCoords();
      renderBoardFromFen(currentFen);
      hydrateHistoryFromStorage();
      setAnalysisStatus(statusEl?.textContent || 'Готовимся к анализу...');
      const currentRowIndex = historyCursor >= 0 ? historyPlies[historyCursor]?.rowIndex : null;
      const shouldAttachToHistory = !analysisHistory.length;
      analyzePosition({
        attachToHistory: shouldAttachToHistory,
        targetRowIndex: shouldAttachToHistory ? null : currentRowIndex
      });
      if (refreshBtn){
        refreshBtn.addEventListener('click', () => {
          const targetRowIndex = historyCursor >= 0 ? historyPlies[historyCursor]?.rowIndex : null;
          analyzePosition({
            force: true,
            attachToHistory: targetRowIndex === null,
            targetRowIndex
          });
        });
      }
      if (historyFirstBtn) historyFirstBtn.addEventListener('click', () => scrollHistory('top'));
      if (historyUpBtn) historyUpBtn.addEventListener('click', () => scrollHistory('up'));
      if (historyDownBtn) historyDownBtn.addEventListener('click', () => scrollHistory('down'));
      if (historyLastBtn) historyLastBtn.addEventListener('click', () => scrollHistory('bottom'));
      promotionButtons.forEach((btn) => {
        btn.addEventListener('click', () => handlePromotionChoice(btn.dataset.piece));
      });
    }

    init();
  </script>
</body>
</html>
