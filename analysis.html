<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <title>Stockfish анализ</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/1.0.0/chess.min.js"></script>
  <style>
    :root{
      --dark:#769656;
      --light:#eeeed2;
      --bg:#111;
      --panel:rgba(255,255,255,.06);
      --border:rgba(255,255,255,.12);
      --text:#fff;
    }
    body{
      margin:0;
      padding:16px;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:var(--bg);
      color:var(--text);
    }
    .wrap{ max-width: 1180px; margin:0 auto; display:grid; gap:14px; }
    .layout{ display:flex; flex-direction:column; gap:14px; align-items:stretch; }
    .panel{
      padding:14px;
      border-radius:12px;
      border:1px solid var(--border);
      background:var(--panel);
      box-shadow: 0 12px 30px rgba(0,0,0,.35);
    }
    h2{ margin:0 0 6px 0; }
    code{ word-break: break-all; }
    .status{ opacity:.85; margin:4px 0 0 0; font-size:14px; }
    .list{ margin:10px 0 0 0; padding:0; list-style:none; display:grid; gap:10px; }
    .list li{ border:1px solid var(--border); border-radius:10px; padding:10px; background: rgba(0,0,0,.35); }
    .actions{ display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }
    .btn{ cursor:pointer; border:1px solid var(--border); background:rgba(255,255,255,.08); color:var(--text); padding:10px 14px; border-radius:10px; font-weight:600; }
    .btn:disabled{ opacity:.5; cursor:not-allowed; }
    .field{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:10px; }
    .field input{ flex:1 1 240px; padding:10px; border-radius:10px; border:1px solid var(--border); background:rgba(0,0,0,.35); color:var(--text); }
    .mono{ font-family: ui-monospace, SFMono-Regular, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace; }

    /* board */
    .board-panel{ display:grid; gap:12px; justify-items:center; }
    .board-wrapper{
      position: relative;
      width:min(620px, 100%);
      margin:0 auto;
      display:grid;
      grid-template-columns: 18px auto 1fr;
      grid-template-rows: 1fr auto;
      grid-template-areas:
        "cp ranks board"
        "cp . files";
      column-gap: 10px;
      row-gap: 8px;
      align-items: stretch;
    }
    .board{
      grid-area: board;
      width:100%;
      aspect-ratio: 1 / 1;
      display:block;
      border-radius:14px;
      overflow:hidden;
      box-shadow: 0 12px 40px rgba(0,0,0,.45);
      user-select:none;
      -webkit-user-select:none;
      touch-action: none;
      position:relative;
    }
    .board-squares{
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      grid-auto-rows: 1fr;
      width:100%;
      height:100%;
    }
    .board-arrows{
      position:absolute;
      inset:0;
      pointer-events:none;
    }
    .arrow-path{
      stroke:#6ccf70;
      stroke-width:10;
      stroke-linecap:round;
      stroke-linejoin:round;
      fill:none;
      opacity:0.65;
    }
    .arrow-head{
      fill:#6ccf70;
      opacity:0.65;
    }
    .eval-bar{
      grid-area: cp;
      position: relative;
      width: 18px;
      background: linear-gradient(180deg, #333 0%, #f5f5f5 100%);
      border-radius: 10px;
      overflow:hidden;
      border:1px solid var(--border);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.15);
    }
    .eval-fill{
      position:absolute;
      bottom:0;
      left:0;
      right:0;
      background:#f5f5f5;
      transition:height .2s ease;
      height:50%;
    }
    .eval-label{
      position:absolute;
      bottom:4px;
      left:50%;
      transform:translateX(-50%);
      color:#000;
      font-size:10px;
      font-weight:700;
      text-shadow:0 1px 3px rgba(0,0,0,.25);
      pointer-events:none;
    }
    .coord-files,
    .coord-ranks{
      pointer-events: none;
      color: rgba(255,255,255,.8);
      text-shadow: 0 1px 3px rgba(0,0,0,.35);
      font-weight: 700;
      font-size: clamp(11px, 2.5vw, 14px);
    }
    .coord-files{
      grid-area: files;
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      text-align: center;
      padding: 0 4px 0 0;
    }
    .coord-ranks{
      grid-area: ranks;
      display:grid;
      grid-template-rows: repeat(8, 1fr);
      align-items: center;
      justify-items: end;
      width: 26px;
      padding-right: 4px;
      align-self: stretch;
      height: 100%;
    }
    .sq{
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: clamp(22px, 6vw, 44px);
      line-height: 1;
      aspect-ratio: 1 / 1;
      overflow: hidden;
      min-width: 0;
      min-height: 0;
      position: relative;
    }
    .light{ background:var(--light); }
    .dark{ background:var(--dark); }
    .piece{
      width: auto;
      height: auto;
      display:flex;
      align-items:center;
      justify-content:center;
      line-height: 1;
      pointer-events: none;
    }
    .piece img{ width: 140.712%; height: 140.712%; display:block; user-select:none; -webkit-user-select:none; }
    .selected{ outline: 3px solid rgba(255,255,255,.6); }
    .info-grid{ display:grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap:14px; }
    .history-panel{ grid-column: 1 / -1; }
    .analysis-history{ list-style:none; padding:0; margin:0; display:grid; gap:10px; }
    .analysis-history li{ border:1px solid var(--border); border-radius:10px; padding:10px; background: rgba(0,0,0,.35); }
    .analysis-history .meta{ font-size:13px; opacity:.8; margin-bottom:4px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div>
      <h2>Stockfish анализ позиции</h2>
      <p class="status">Окно анализа открывается из главной доски и использует переданный FEN.</p>
    </div>

    <div class="layout">
      <div class="panel board-panel">
        <div class="board-wrapper">
          <div class="eval-bar" aria-hidden="true">
            <div class="eval-fill" id="evalFill"></div>
            <div class="eval-label" id="evalLabel">0.0</div>
          </div>
          <div id="ranksLeft" class="coord-ranks"></div>
          <div id="board" class="board" aria-label="Доска для визуализации позиции">
            <svg id="boardArrows" class="board-arrows" viewBox="0 0 800 800"></svg>
            <div id="boardSquares" class="board-squares"></div>
          </div>
          <div id="filesBottom" class="coord-files"></div>
        </div>
        <div class="status mono" id="boardFen"></div>
      </div>

      <div class="info-grid">
        <div class="panel">
          <div><strong>FEN:</strong> <code id="fenText"></code></div>
          <div class="actions">
            <button class="btn" id="refreshBtn">Обновить анализ</button>
          </div>
          <p id="engineStatus" class="status">Готовимся к анализу...</p>
          <ul id="analysisList" class="list" aria-live="polite" aria-atomic="true"></ul>
        </div>

        <div class="panel">
          <h3 style="margin:0">Проверка хода</h3>
          <p class="status">Введите ход в формате UCI или передайте его из основной доски.</p>
          <div class="field">
            <input id="moveInput" type="text" inputmode="text" autocomplete="off" placeholder="Например: e2e4" />
            <button class="btn" id="evaluateBtn">Проверить</button>
          </div>
          <div id="moveStatus" class="status" style="margin-top:8px"></div>
          <ul id="moveDetails" class="list"></ul>
        </div>

        <div class="panel history-panel">
          <h3 style="margin:0 0 6px">История анализа</h3>
          <p class="status">Последние анализы после изменений позиции.</p>
          <ul id="analysisHistory" class="analysis-history"></ul>
        </div>
      </div>
    </div>
  </div>

  <script>
    const params = new URLSearchParams(window.location.search);
    const initialFen = params.get('fen');
    const moveFromQuery = params.get('move') || '';

    const files = ['a','b','c','d','e','f','g','h'];
    const ranks = ['8','7','6','5','4','3','2','1'];

    const WHITE_SVG = {
      P: 'icone/white/Chess_plt45.svg',
      N: 'icone/white/Chess_nlt45.svg',
      B: 'icone/white/Chess_blt45.svg',
      R: 'icone/white/Chess_rlt45.svg',
      Q: 'icone/white/Chess_qlt45.svg',
      K: 'icone/white/Chess_klt45.svg'
    };

    const BLACK_SVG = {
      p: 'icone/black/Chess_pdt45.svg',
      n: 'icone/black/Chess_ndt45.svg',
      b: 'icone/black/Chess_bdt45.svg',
      r: 'icone/black/Chess_rdt45.svg',
      q: 'icone/black/Chess_qdt45.svg',
      k: 'icone/black/Chess_kdt45.svg'
    };

    const fenTextEl = document.getElementById('fenText');
    const statusEl = document.getElementById('engineStatus');
    const analysisListEl = document.getElementById('analysisList');
    const analysisHistoryEl = document.getElementById('analysisHistory');
    const refreshBtn = document.getElementById('refreshBtn');
    const moveInput = document.getElementById('moveInput');
    const evaluateBtn = document.getElementById('evaluateBtn');
    const moveStatusEl = document.getElementById('moveStatus');
    const moveDetailsEl = document.getElementById('moveDetails');
    const boardSquaresEl = document.getElementById('boardSquares');
    const arrowsEl = document.getElementById('boardArrows');
    const boardFenEl = document.getElementById('boardFen');
    const filesBottomEl = document.getElementById('filesBottom');
    const ranksLeftEl = document.getElementById('ranksLeft');
    const evalFillEl = document.getElementById('evalFill');
    const evalLabelEl = document.getElementById('evalLabel');

    const ANALYZE_URL = 'http://127.0.0.1:8000/analyze';
    const EVAL_URL = 'http://127.0.0.1:8000/evaluate_move';
    const CACHE_TTL_MS = 10_000;
    const analyzeCache = new Map();
    const analysisHistory = [];
    let currentFen = initialFen;
    let boardState = [];
    let activeColor = 'w';
    let fullmove = 1;
    let selectedSq = null;
    let chess = null;
    let autoReplyPending = false;

    function renderAnalysisLines(lines = [], { fromCache = false } = {}){
      analysisListEl.innerHTML = '';
      if (!lines.length){
        const empty = document.createElement('li');
        empty.textContent = 'Нет данных анализа';
        analysisListEl.appendChild(empty);
        updateArrow(null);
        updateEvalBar(null);
        return;
      }
      lines.slice(0, 3).forEach((line, idx) => {
        const li = document.createElement('li');
        const title = document.createElement('div');
        title.innerHTML = `<strong>#${idx + 1}</strong> ${line.best_move_uci || '—'}`;
        const scoreText = line.mate !== undefined && line.mate !== null
          ? `Мат за ${line.mate}`
          : (line.score_cp !== undefined && line.score_cp !== null ? `${(Number(line.score_cp) / 100).toFixed(2)} cp` : '—');
        const score = document.createElement('div');
        score.innerHTML = `<span class="mono">${scoreText}</span>`;
        const pv = document.createElement('div');
        pv.textContent = line.pv_san || '—';
        pv.classList.add('mono');
        li.appendChild(title);
        li.appendChild(score);
        li.appendChild(pv);
        analysisListEl.appendChild(li);
      });
      statusEl.textContent = fromCache ? 'Показан кешированный анализ (до 10 секунд).' : 'Анализ обновлён.';
      updateArrow(lines?.[0]);
      updateEvalBar(lines?.[0]);
    }

    function renderMoveResult(data){
      moveDetailsEl.innerHTML = '';
      if (!data){
        moveStatusEl.textContent = 'Нет данных по ходу.';
        return;
      }
      moveStatusEl.textContent = `Оценка: ${data.label || '—'}`;
      const rows = [
        { label: 'Дельта (cp)', value: data.delta_cp },
        { label: 'Лучший ход', value: data.best_move_uci },
        { label: 'Лучшая линия', value: data.best_line?.pv_san },
        { label: 'Линия после хода', value: data.after_line?.pv_san },
      ];
      rows.forEach((row) => {
        const li = document.createElement('li');
        const title = document.createElement('div');
        title.innerHTML = `<strong>${row.label}</strong>`;
        const value = document.createElement('div');
        value.textContent = row.value !== undefined && row.value !== null ? row.value : '—';
        value.classList.add('mono');
        li.appendChild(title);
        li.appendChild(value);
        moveDetailsEl.appendChild(li);
      });
    }

    function fenToBoard(fenStr){
      const placement = (fenStr || '').split(' ')[0];
      if (!placement) return Array.from({ length: 8 }, () => Array(8).fill(''));
      const rows = placement.split('/');
      if (rows.length !== 8) return Array.from({ length: 8 }, () => Array(8).fill(''));
      const board = [];
      for (const row of rows){
        const cols = [];
        for (const ch of row){
          if (/[1-8]/.test(ch)){
            for (let i = 0; i < Number(ch); i++) cols.push('');
          } else {
            cols.push(ch);
          }
        }
        board.push(cols);
      }
      return board;
    }

    function parseFenState(fenStr){
      const parts = (fenStr || '').split(' ');
      const board = fenToBoard(fenStr);
      const active = parts[1] === 'b' ? 'b' : 'w';
      const moveNumber = Number(parts[5]) || 1;
      return { board, active, fullmove: moveNumber };
    }

    function boardToFen(board, active = 'w', moveNumber = 1){
      const rows = board.map((row) => {
        let res = '';
        let empty = 0;
        for (const cell of row){
          if (!cell){
            empty++;
          } else {
            if (empty){ res += empty; empty = 0; }
            res += cell;
          }
        }
        if (empty) res += empty;
        return res;
      });
      const placement = rows.join('/');
      return `${placement} ${active} - - 0 ${moveNumber}`;
    }

    function renderBoardCoords(){
      if (!filesBottomEl || !ranksLeftEl) return;
      filesBottomEl.innerHTML = '';
      ranksLeftEl.innerHTML = '';
      files.forEach((file) => {
        const span = document.createElement('span');
        span.textContent = file;
        filesBottomEl.appendChild(span);
      });
      ranks.forEach((rank) => {
        const span = document.createElement('span');
        span.textContent = rank;
        ranksLeftEl.appendChild(span);
      });
    }

    function renderBoardFromFen(fenStr){
      if (!boardSquaresEl) return;
      boardSquaresEl.innerHTML = '';
      const grid = fenToBoard(fenStr);
      grid.forEach((row, rowIdx) => {
        row.forEach((cell, colIdx) => {
          const sq = document.createElement('div');
          const isLight = (rowIdx + colIdx) % 2 === 0;
          const coord = `${files[colIdx]}${ranks[rowIdx]}`;
          sq.className = `sq ${isLight ? 'light' : 'dark'}`;
          sq.dataset.square = coord;
          sq.addEventListener('click', () => handleSquareClick(coord));
          if (cell){
            const piece = document.createElement('div');
            const img = document.createElement('img');
            const isWhite = /[PNBRQK]/.test(cell);
            const src = isWhite ? WHITE_SVG[cell] : BLACK_SVG[cell];
            if (src) img.src = src;
            piece.className = `piece ${isWhite ? 'white' : 'black'}`;
            piece.appendChild(img);
            sq.appendChild(piece);
          }
          boardSquaresEl.appendChild(sq);
        });
      });
      if (selectedSq){
        const sqEl = boardSquaresEl.querySelector(`[data-square="${selectedSq}"]`);
        if (sqEl) sqEl.classList.add('selected');
      }
      if (boardFenEl) boardFenEl.textContent = fenStr || 'FEN не передан';
    }

    function uciToCoords(uci){
      if (!uci || uci.length < 4) return null;
      return { from: uci.slice(0,2), to: uci.slice(2,4) };
    }

    function updateArrow(line){
      if (!arrowsEl) return;
      arrowsEl.innerHTML = '';
      const move = line?.best_move_uci;
      const coords = uciToCoords(move);
      if (!coords) return;
      const startFile = files.indexOf(coords.from[0]);
      const startRank = ranks.indexOf(coords.from[1]);
      const endFile = files.indexOf(coords.to[0]);
      const endRank = ranks.indexOf(coords.to[1]);
      if (startFile < 0 || startRank < 0 || endFile < 0 || endRank < 0) return;
      const cell = 100;
      const offset = cell / 2;
      const x1 = startFile * cell + offset;
      const y1 = startRank * cell + offset;
      const x2 = endFile * cell + offset;
      const y2 = endRank * cell + offset;

      const path = document.createElementNS('http://www.w3.org/2000/svg','line');
      path.setAttribute('x1', x1);
      path.setAttribute('y1', y1);
      path.setAttribute('x2', x2);
      path.setAttribute('y2', y2);
      path.classList.add('arrow-path');

      const marker = document.createElementNS('http://www.w3.org/2000/svg','polygon');
      const angle = Math.atan2(y2 - y1, x2 - x1);
      const headLength = 22;
      const headWidth = 16;
      const hx = x2 - Math.cos(angle) * headLength;
      const hy = y2 - Math.sin(angle) * headLength;
      const p1x = hx + Math.cos(angle + Math.PI / 2) * headWidth;
      const p1y = hy + Math.sin(angle + Math.PI / 2) * headWidth;
      const p2x = hx + Math.cos(angle - Math.PI / 2) * headWidth;
      const p2y = hy + Math.sin(angle - Math.PI / 2) * headWidth;
      marker.setAttribute('points', `${x2},${y2} ${p1x},${p1y} ${p2x},${p2y}`);
      marker.classList.add('arrow-head');

      arrowsEl.appendChild(path);
      arrowsEl.appendChild(marker);
    }

    function updateEvalBar(line){
      if (!evalFillEl || !evalLabelEl) return;
      const mate = line?.mate;
      let cp = Number(line?.score_cp);
      let label = '0.0';
      if (mate !== undefined && mate !== null){
        label = `M${mate}`;
        cp = mate > 0 ? 900 : -900;
      } else if (!Number.isNaN(cp)){
        label = (cp / 100).toFixed(1);
      } else {
        cp = 0;
      }
      const normalized = 1 / (1 + Math.exp(-cp / 200));
      const percent = Math.round(normalized * 100);
      evalFillEl.style.height = `${percent}%`;
      evalLabelEl.textContent = label;
    }

    function extractErrorDetail(errObj, fallback){
      if (errObj && typeof errObj === 'object' && 'detail' in errObj){
        if (typeof errObj.detail === 'string') return errObj.detail;
        try { return JSON.stringify(errObj.detail); } catch (_) {}
      }
      return fallback || 'Неизвестная ошибка';
    }

    async function fetchJson(url, payload){
      const response = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      const text = await response.text();
      let data = null;
      try { data = text ? JSON.parse(text) : null; } catch (_) { data = null; }
      if (!response.ok){
        const detail = extractErrorDetail(data, text || `${response.status} ${response.statusText}`);
        throw new Error(detail);
      }
      return data;
    }

    async function analyzePosition(force = false){
      if (!currentFen){
        statusEl.textContent = 'FEN не передан. Вернитесь на главную и откройте анализ заново.';
        return;
      }

      const cached = analyzeCache.get(currentFen);
      const now = Date.now();
      if (!force && cached && now - cached.timestamp < CACHE_TTL_MS){
        renderAnalysisLines(cached.data?.lines || [], { fromCache: true });
        return;
      }

      statusEl.textContent = 'Запрашиваем анализ у сервера...';
      refreshBtn.disabled = true;
      try {
        const payload = { fen: currentFen, movetime_ms: 250, multipv: 3, side: 'turn' };
        const data = await fetchJson(ANALYZE_URL, payload);
        const lines = data?.lines || data?.analysis || [];
        analyzeCache.set(currentFen, { timestamp: now, data: { lines } });
        renderAnalysisLines(lines, { fromCache: false });
        pushAnalysisHistory(currentFen, lines);
        if (autoReplyPending){
          const bestMove = lines?.[0]?.best_move_uci;
          if (bestMove) {
            playBestMove(bestMove);
          }
          autoReplyPending = false;
        }
      } catch (err){
        statusEl.textContent = `Ошибка анализа: ${err.message}`;
        analysisListEl.innerHTML = '';
      } finally {
        refreshBtn.disabled = false;
      }
    }

    async function evaluateMove(moveUci){
      if (!currentFen){
        moveStatusEl.textContent = 'FEN не передан. Вернитесь на главную и откройте анализ заново.';
        return;
      }
      if (!moveUci){
        moveStatusEl.textContent = 'Введите ход в формате UCI.';
        return;
      }

      moveStatusEl.textContent = 'Отправляем ход на проверку...';
      evaluateBtn.disabled = true;
      try {
        const payload = { fen: currentFen, move_uci: moveUci, movetime_ms: 250, side: 'turn' };
        const data = await fetchJson(EVAL_URL, payload);
        renderMoveResult(data);
      } catch (err){
        moveStatusEl.textContent = `Ошибка проверки: ${err.message}`;
        moveDetailsEl.innerHTML = '';
      } finally {
        evaluateBtn.disabled = false;
      }
    }

    function handleIncomingMove(event){
      const data = event?.data;
      if (!data || typeof data !== 'object') return;
      if (data.type === 'evaluate-move' && data.move_uci){
        moveInput.value = data.move_uci;
        evaluateMove(data.move_uci);
      }
    }

    function pushAnalysisHistory(fenValue, lines){
      if (!analysisHistoryEl) return;
      const entry = { fen: fenValue, createdAt: new Date(), lines: lines?.slice(0,3) || [] };
      analysisHistory.unshift(entry);
      analysisHistory.splice(10);
      analysisHistoryEl.innerHTML = '';
      analysisHistory.forEach((item) => {
        const li = document.createElement('li');
        const meta = document.createElement('div');
        meta.className = 'meta';
        meta.textContent = item.createdAt.toLocaleTimeString();
        li.appendChild(meta);
        const fenRow = document.createElement('div');
        fenRow.innerHTML = `<strong>FEN</strong>: <span class="mono">${item.fen}</span>`;
        li.appendChild(fenRow);
        item.lines.forEach((line, idx) => {
          const row = document.createElement('div');
          const scoreText = line.mate !== undefined && line.mate !== null
            ? `Мат за ${line.mate}`
            : (line.score_cp !== undefined && line.score_cp !== null ? `${(Number(line.score_cp) / 100).toFixed(2)} cp` : '—');
          row.innerHTML = `<strong>#${idx + 1}</strong> ${line.best_move_uci || '—'} — <span class="mono">${scoreText}</span>`;
          li.appendChild(row);
        });
        analysisHistoryEl.appendChild(li);
      });
    }

    function getPieceAt(square){
      const fileIdx = files.indexOf(square[0]);
      const rankIdx = ranks.indexOf(square[1]);
      if (fileIdx < 0 || rankIdx < 0) return '';
      return boardState[rankIdx]?.[fileIdx] || '';
    }

    function setPieceAt(square, value){
      const fileIdx = files.indexOf(square[0]);
      const rankIdx = ranks.indexOf(square[1]);
      if (fileIdx < 0 || rankIdx < 0) return;
      boardState[rankIdx][fileIdx] = value;
    }

    function pieceColor(piece){
      if (!piece) return null;
      return /[PNBRQK]/.test(piece) ? 'w' : 'b';
    }

    function syncFromChess(){
      if (!chess) return;
      currentFen = chess.fen();
      const parsed = parseFenState(currentFen);
      boardState = parsed.board;
      activeColor = parsed.active;
      fullmove = parsed.fullmove;
      fenTextEl.textContent = currentFen || '—';
      renderBoardFromFen(currentFen);
    }

    function playBestMove(bestMoveUci){
      if (!bestMoveUci || !chess) return;
      const move = chess.move({ from: bestMoveUci.slice(0,2), to: bestMoveUci.slice(2,4), promotion: bestMoveUci[4] || 'q' });
      if (!move) return;
      syncFromChess();
      analyzePosition(true);
    }

    function handleSquareClick(square){
      const piece = getPieceAt(square);
      const turn = chess?.turn?.() || activeColor;

      if (selectedSq && selectedSq !== square){
        const move = chess?.move({ from: selectedSq, to: square, promotion: 'q' });
        if (move){
          selectedSq = null;
          autoReplyPending = true;
          syncFromChess();
          analyzePosition(true);
          return;
        }
      }

      if (piece && pieceColor(piece) === turn){
        selectedSq = square;
      } else {
        selectedSq = null;
      }
      renderBoardFromFen(currentFen);
    }

    function init(){
      currentFen = initialFen || '8/8/8/8/8/8/8/8 w - - 0 1';
      try {
        chess = new Chess(currentFen);
      } catch (_) {
        chess = new Chess('8/8/8/8/8/8/8/8 w - - 0 1');
      }
      syncFromChess();
      renderBoardCoords();
      moveInput.value = moveFromQuery;
      analyzePosition();
      refreshBtn.addEventListener('click', () => analyzePosition(true));
      evaluateBtn.addEventListener('click', () => evaluateMove(moveInput.value.trim()));
      window.addEventListener('message', handleIncomingMove);
      if (moveFromQuery){
        evaluateMove(moveFromQuery);
      }
    }

    init();
  </script>
</body>
</html>
